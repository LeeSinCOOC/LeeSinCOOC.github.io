<!DOCTYPE html>





<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/bitbug_favicon1.ico?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/bitbug_favicon.ico?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"right","display":"hide","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    save_scroll: false,
    copycode: {"enable":true,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta name="description" content="图像的基本操作目标 访问像素值并修改它们 访问图像属性 设置兴趣区（ROI） 分割和合并图像本节中的几乎所有操作都主要与Numpy相关，而不是与OpenCV相关。要使用OpenCV编写更好的优化代码，需要Numpy的丰富知识。 （由于大多数示例都是单行代码，因此示例将在Python终端中显示）访问和修改像素值">
<meta name="keywords" content="python,tensorflow,pytorch,人工智能">
<meta property="og:type" content="article">
<meta property="og:title" content="OpenCV的核心操作">
<meta property="og:url" content="http://leesin.cc/opencv/OpenCV的核心操作.html">
<meta property="og:site_name" content="Chen Jian&#39;s Blog">
<meta property="og:description" content="图像的基本操作目标 访问像素值并修改它们 访问图像属性 设置兴趣区（ROI） 分割和合并图像本节中的几乎所有操作都主要与Numpy相关，而不是与OpenCV相关。要使用OpenCV编写更好的优化代码，需要Numpy的丰富知识。 （由于大多数示例都是单行代码，因此示例将在Python终端中显示）访问和修改像素值">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://leesin.cc/opencv/images/roi.jpg">
<meta property="og:image" content="http://leesin.cc/opencv/images/border.jpg">
<meta property="og:image" content="http://leesin.cc/opencv/images/blending.jpg">
<meta property="og:image" content="http://leesin.cc/opencv/images/overlay.jpg">
<meta property="og:updated_time" content="2019-10-08T11:59:45.965Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OpenCV的核心操作">
<meta name="twitter:description" content="图像的基本操作目标 访问像素值并修改它们 访问图像属性 设置兴趣区（ROI） 分割和合并图像本节中的几乎所有操作都主要与Numpy相关，而不是与OpenCV相关。要使用OpenCV编写更好的优化代码，需要Numpy的丰富知识。 （由于大多数示例都是单行代码，因此示例将在Python终端中显示）访问和修改像素值">
<meta name="twitter:image" content="http://leesin.cc/opencv/images/roi.jpg">
  <link rel="canonical" href="http://leesin.cc/opencv/OpenCV的核心操作">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>OpenCV的核心操作 | Chen Jian's Blog</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  <div class="container sidebar-position-right">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Chen Jian's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-reading">
      
    

    <a href="/reading/" rel="section"><i class="menu-item-icon fa fa-fw fa-book"></i> <br>笔记</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-miscellaneous">
      
    

    <a href="/miscellaneous/" rel="section"><i class="menu-item-icon fa fa-fw fa-link"></i> <br>常用网站</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
      </li>
    
  </ul>

    

</nav>
  <div class="site-search">
    
  <div class="popup search-popup">
  <div class="search-header">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <div class="search-input-wrapper">
      <input autocomplete="off" autocorrect="off" autocapitalize="none"
             placeholder="搜索..." spellcheck="false"
             type="text" id="search-input">
    </div>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>
  <div id="search-result"></div>
</div>


  </div>
</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content page-post-detail">
            

  <div id="posts" class="posts-expand">
    

  <article class="post" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://leesin.cc/opencv/OpenCV的核心操作.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈 建">
      <meta itemprop="description" content="当时明月在，曾照彩云归">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen Jian's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">OpenCV的核心操作

          
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-10-03 23:11:00" itemprop="dateCreated datePublished" datetime="2019-10-03T23:11:00+08:00">2019-10-03</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-08 19:59:45" itemprop="dateModified" datetime="2019-10-08T19:59:45+08:00">2019-10-08</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/OpenCV-Python-教程/" itemprop="url" rel="index"><span itemprop="name">OpenCV-Python 教程</span></a></span>

                
                
              
            </span>
          

          
            <span class="post-meta-item" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="图像的基本操作"><a href="#图像的基本操作" class="headerlink" title="图像的基本操作"></a>图像的基本操作</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>访问像素值并修改它们</li>
<li>访问图像属性</li>
<li>设置兴趣区（ROI）</li>
<li>分割和合并图像<br>本节中的几乎所有操作都主要与Numpy相关，而不是与OpenCV相关。要使用OpenCV编写更好的优化代码，需要Numpy的丰富知识。</li>
</ul><p><em>（由于大多数示例都是单行代码，因此示例将在Python终端中显示）</em></p><h2 id="访问和修改像素值"><a href="#访问和修改像素值" class="headerlink" title="访问和修改像素值"></a>访问和修改像素值</h2><a id="more"></a>

<p>让我们先加载彩色图像：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>img = cv.imread(<span class="string">'messi5.jpg'</span>)</span><br></pre></td></tr></table></figure>

<p>您可以通过像素值的行和列坐标来访问它。对于BGR图像，它将返回一个蓝色，绿色，红色值的数组。对于灰度图像，仅返回相应的强度。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>px = img[<span class="number">100</span>,<span class="number">100</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print( px )</span><br><span class="line">[<span class="number">157</span> <span class="number">166</span> <span class="number">200</span>]</span><br><span class="line"><span class="comment"># accessing only blue pixel</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>blue = img[<span class="number">100</span>,<span class="number">100</span>,<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print( blue )</span><br><span class="line"><span class="number">157</span></span><br></pre></td></tr></table></figure>

<p>您可以用相同的方式修改像素值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>img[<span class="number">100</span>,<span class="number">100</span>] = [<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print( img[<span class="number">100</span>,<span class="number">100</span>] )</span><br><span class="line">[<span class="number">255</span> <span class="number">255</span> <span class="number">255</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>警告:Numpy是用于快速数组计算的优化库。因此，简单地访问每个像素值并对其进行修改将非常缓慢，因此不建议使用。</p>
</blockquote>
<blockquote>
<p>注意:上面的方法通常用于选择数组的区域，例如前5行和后3列。对于单个像素访问，Numpy数组方法<code>array.item()</code>和<code>array.itemset()</code>更好，但是它们始终返回标量。如果要访问所有B，G，R值，则需要分别调用所有的<code>array.item()</code>。</p>
</blockquote>
<p>更好的像素访问和编辑方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># accessing RED value</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>img.item(<span class="number">10</span>,<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">59</span></span><br><span class="line"><span class="comment"># modifying RED value</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>img.itemset((<span class="number">10</span>,<span class="number">10</span>,<span class="number">2</span>),<span class="number">100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>img.item(<span class="number">10</span>,<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>

<h2 id="访问图像属性"><a href="#访问图像属性" class="headerlink" title="访问图像属性"></a>访问图像属性</h2><p>图像属性包括行数，列数和通道数，图像数据类型，像素数等。</p>
<p>图像的形状可通过<code>img.shape</code>访问。它返回行，列和通道数的元组（如果图像是彩色的）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print( img.shape )</span><br><span class="line">(<span class="number">342</span>, <span class="number">548</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:如果图像是灰度的，则返回的元组仅包含行数和列数，因此这是检查加载的图像是灰度还是彩色的好方法。</p>
</blockquote>
<p>像素总数可通过访问<code>img.size</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print( img.size )</span><br><span class="line"><span class="number">562248</span></span><br></pre></td></tr></table></figure>

<p>图像数据类型通过<code>img.dtype</code>获得：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print( img.dtype )</span><br><span class="line">uint8</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:<code>img.dtype</code>在调试时非常重要，因为OpenCV-Python代码中的大量错误是由无效的数据类型引起的。</p>
</blockquote>
<h2 id="图像投资回报率"><a href="#图像投资回报率" class="headerlink" title="图像投资回报率"></a>图像投资回报率</h2><p>有时，您将不得不使用图像的某些区域。为了在图像中进行眼睛检测，首先在整个图像上进行面部检测。当获得一张脸时，我们仅选择脸部区域并在其中搜索眼睛，而不是搜索整个图像。它提高了准确性（因为眼睛总是在脸上：D）和性能（因为我们在小范围内搜索）。</p>
<p>使用Numpy索引再次获得ROI。在这里，我要选择球并将其复制到图像中的另一个区域：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ball = img[<span class="number">280</span>:<span class="number">340</span>, <span class="number">330</span>:<span class="number">390</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>img[<span class="number">273</span>:<span class="number">333</span>, <span class="number">100</span>:<span class="number">160</span>] = ball</span><br></pre></td></tr></table></figure>

<p>检查以下结果：<br><img src="images/roi.jpg" alt></p>
<h2 id="分割和合并图像通道"><a href="#分割和合并图像通道" class="headerlink" title="分割和合并图像通道"></a>分割和合并图像通道</h2><p>有时您需要分别处理图像的B，G，R通道。在这种情况下，您需要将BGR图像拆分为单个通道。在其他情况下，您可能需要将这些单独的频道加入BGR图片。您可以通过以下方式简单地做到这一点：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b,g,r = cv.split(img)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>img = cv.merge((b,g,r))</span><br></pre></td></tr></table></figure>

<p>要么</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = img[:,:,<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>假设您要将所有红色像素都设置为零，则无需先拆分通道。numpy索引更快：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>img[:,:,<span class="number">2</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>警告:cv.split()是一项昂贵的操作（就时间而言）。因此，仅在需要时才这样做。否则请进行Numpy索引。</p>
</blockquote>
<h2 id="为图像设置边框（填充）"><a href="#为图像设置边框（填充）" class="headerlink" title="为图像设置边框（填充）"></a>为图像设置边框（填充）</h2><p>如果要在图像周围创建边框（如相框），则可以使用<code>cv.copyMakeBorder()</code>。但是它在卷积运算，零填充等方面有更多应用。此函数采用以下参数：</p>
<ul>
<li><code>src</code>-输入图像</li>
<li><code>top, bottom, left, right</code>边界的宽度，以相应方向上的像素数为单位</li>
<li><code>borderType</code>-定义要添加哪种边框的标志。它可以是以下类型：<ul>
<li><code>cv.BORDER_CONSTANT</code>-添加恒定的彩色边框。该值应作为下一个参数给出。</li>
<li><code>cv.BORDER_REFLECT</code>-边框将是边框元素的镜像，如下所示：fedcba|abcdefgh|hgfedcb</li>
<li><code>cv.BORDER_REFLECT_101</code>或<code>cv.BORDER_DEFAULT</code>-与上述相同，但略有变化，例如：gfedcb|abcdefgh|gfedcba</li>
<li><code>cv.BORDER_REPLICATE</code>-最后一个元素被复制，像这样：aaaaaa|abcdefgh|hhhhhhh</li>
<li><code>cv.BORDER_WRAP</code>-无法解释，它看起来像这样：cdefgh|abcdefgh|abcdefg</li>
<li><code>value</code> -边框颜色，如果边框类型为cv.BORDER_CONSTANT<br>下面是一个示例代码，演示了所有这些边框类型，以便更好地理解：</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">BLUE = [<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">img1 = cv.imread(<span class="string">'opencv-logo.png'</span>)</span><br><span class="line">replicate = cv.copyMakeBorder(img1,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,cv.BORDER_REPLICATE)</span><br><span class="line">reflect = cv.copyMakeBorder(img1,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,cv.BORDER_REFLECT)</span><br><span class="line">reflect101 = cv.copyMakeBorder(img1,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,cv.BORDER_REFLECT_101)</span><br><span class="line">wrap = cv.copyMakeBorder(img1,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,cv.BORDER_WRAP)</span><br><span class="line">constant= cv.copyMakeBorder(img1,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,cv.BORDER_CONSTANT,value=BLUE)</span><br><span class="line">plt.subplot(<span class="number">231</span>),plt.imshow(img1,<span class="string">'gray'</span>),plt.title(<span class="string">'ORIGINAL'</span>)</span><br><span class="line">plt.subplot(<span class="number">232</span>),plt.imshow(replicate,<span class="string">'gray'</span>),plt.title(<span class="string">'REPLICATE'</span>)</span><br><span class="line">plt.subplot(<span class="number">233</span>),plt.imshow(reflect,<span class="string">'gray'</span>),plt.title(<span class="string">'REFLECT'</span>)</span><br><span class="line">plt.subplot(<span class="number">234</span>),plt.imshow(reflect101,<span class="string">'gray'</span>),plt.title(<span class="string">'REFLECT_101'</span>)</span><br><span class="line">plt.subplot(<span class="number">235</span>),plt.imshow(wrap,<span class="string">'gray'</span>),plt.title(<span class="string">'WRAP'</span>)</span><br><span class="line">plt.subplot(<span class="number">236</span>),plt.imshow(constant,<span class="string">'gray'</span>),plt.title(<span class="string">'CONSTANT'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>请参阅下面的结果。（图像与matplotlib一起显示。因此红色和蓝色通道将互换）：<br><img src="images/border.jpg" alt></p>
<h1 id="图像上的算术运算"><a href="#图像上的算术运算" class="headerlink" title="图像上的算术运算"></a>图像上的算术运算</h1><h2 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h2><ul>
<li>学习图像的几种算术运算，例如加法，减法，按位运算等。</li>
<li>您将学习以下功能：<code>cv.add()</code>，<code>cv.addWeighted()</code>等。</li>
</ul>
<h2 id="图像加法"><a href="#图像加法" class="headerlink" title="图像加法"></a>图像加法</h2><p>您可以通过OpenCV函数<code>cv.add()</code>或仅通过numpy操作<code>（res = img1 + img2 ）</code>添加两个图像。两个图像应具有相同的深度和类型，或者第二个图像可以只是一个标量值。</p>
<blockquote>
<p>注意:OpenCV加法和Numpy加法之间有区别。OpenCV加法是饱和运算，而Numpy加法是模运算。<br>例如，考虑以下示例：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = np.uint8([<span class="number">250</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = np.uint8([<span class="number">10</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print( cv.add(x,y) ) <span class="comment"># 250+10 = 260 =&gt; 255</span></span><br><span class="line">[[<span class="number">255</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print( x+y )          <span class="comment"># 250+10 = 260 % 256 = 4</span></span><br><span class="line">[<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p>当添加两个图像时，它将更加可见。OpenCV功能将提供更好的结果。因此，始终最好坚持使用OpenCV功能。</p>
<h2 id="图像融合"><a href="#图像融合" class="headerlink" title="图像融合"></a>图像融合</h2><p>这也是图像加法，但是对图像赋予不同的权重，以使其具有融合或透明的感觉。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">img1 = cv.imread(<span class="string">'ml.png'</span>)</span><br><span class="line">img2 = cv.imread(<span class="string">'opencv-logo.png'</span>)</span><br><span class="line">dst = cv.addWeighted(img1,<span class="number">0.7</span>,img2,<span class="number">0.3</span>,<span class="number">0</span>)</span><br><span class="line">cv.imshow(<span class="string">'dst'</span>,dst)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<p>检查以下结果：<br><img src="images/blending.jpg" alt></p>
<h2 id="按位运算"><a href="#按位运算" class="headerlink" title="按位运算"></a>按位运算</h2><p>这包括按位与，或，非和异或运算。在提取图像的任何部分（如我们将在后续章节中看到），定义和使用非矩形ROI等方面，它们将非常有用。下面我们将看到有关如何更改图像特定区域的示例。</p>
<p>我想在图像上方放置OpenCV徽标。如果添加两个图像，它将改变颜色。如果混合它，我将获得透明效果。但我希望它不透明。如果是矩形区域，则可以像上一章一样使用ROI。但是OpenCV徽标不是矩形。因此，您可以按如下所示进行按位操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Load two images</span></span><br><span class="line">img1 = cv.imread(<span class="string">'messi5.jpg'</span>)</span><br><span class="line">img2 = cv.imread(<span class="string">'opencv-logo-white.png'</span>)</span><br><span class="line"><span class="comment"># I want to put logo on top-left corner, So I create a ROI</span></span><br><span class="line">rows,cols,channels = img2.shape</span><br><span class="line">roi = img1[<span class="number">0</span>:rows, <span class="number">0</span>:cols ]</span><br><span class="line"><span class="comment"># Now create a mask of logo and create its inverse mask also</span></span><br><span class="line">img2gray = cv.cvtColor(img2,cv.COLOR_BGR2GRAY)</span><br><span class="line">ret, mask = cv.threshold(img2gray, <span class="number">10</span>, <span class="number">255</span>, cv.THRESH_BINARY)</span><br><span class="line">mask_inv = cv.bitwise_not(mask)</span><br><span class="line"><span class="comment"># Now black-out the area of logo in ROI</span></span><br><span class="line">img1_bg = cv.bitwise_and(roi,roi,mask = mask_inv)</span><br><span class="line"><span class="comment"># Take only region of logo from logo image.</span></span><br><span class="line">img2_fg = cv.bitwise_and(img2,img2,mask = mask)</span><br><span class="line"><span class="comment"># Put logo in ROI and modify the main image</span></span><br><span class="line">dst = cv.add(img1_bg,img2_fg)</span><br><span class="line">img1[<span class="number">0</span>:rows, <span class="number">0</span>:cols ] = dst</span><br><span class="line">cv.imshow(<span class="string">'res'</span>,img1)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<p>请参阅下面的结果。左图显示了我们创建的遮罩。右图显示了最终结果。为了进一步理解，请显示以上代码中的所有中间图像，尤其是img1_bg和img2_fg。<br><img src="images/overlay.jpg" alt></p>
<h1 id="绩效评估和改进技术"><a href="#绩效评估和改进技术" class="headerlink" title="绩效评估和改进技术"></a>绩效评估和改进技术</h1><h2 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h2><p>在图像处理中，由于每秒要处理大量操作，因此必须使代码不仅提供正确的解决方案，而且还必须以最快的方式提供代码。因此，在本章中，您将学习</p>
<ul>
<li>衡量代码的性能。</li>
<li>一些提高代码性能的技巧。</li>
<li>您将看到以下功能：<code>cv.getTickCount</code>，<code>cv.getTickFrequency</code>等。<br>除了OpenCV，Python还提供了一个模块<strong>时间</strong>，这有助于衡量执行时间。另一个模块<strong>配置文件</strong>有助于获取有关代码的详细报告，例如代码中每个函数花费了多少时间，函数被调用了多少次等。但是，如果您使用的是IPython，则所有这些功能都集成在用户友好的界面中方式。我们将看到一些重要的信息，有关更多详细信息，请查看“ 其他资源”部分中的链接。</li>
</ul>
<h2 id="使用OpenCV衡量性能"><a href="#使用OpenCV衡量性能" class="headerlink" title="使用OpenCV衡量性能"></a>使用OpenCV衡量性能</h2><p><code>cv.getTickCount</code>函数返回从参考事件（如打开机器的那一刻）到调用此函数一刻之间的时钟周期数。因此，如果在函数执行之前和之后调用它，则会获得用于执行函数的时钟周期数。</p>
<p><code>cv.getTickFrequency</code>函数返回时钟周期的频率或每秒的时钟周期数。因此，要找到执行时间（以秒为单位），您可以执行以下操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">e1 = cv.getTickCount()</span><br><span class="line"><span class="comment"># your code execution</span></span><br><span class="line">e2 = cv.getTickCount()</span><br><span class="line">time = (e2 - e1)/ cv.getTickFrequency()</span><br></pre></td></tr></table></figure>

<p>我们将通过以下示例进行演示。下面的示例应用中位数过滤，其内核的奇数范围为5到49。（不用担心结果会是什么样，这不是我们的目标）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">img1 = cv.imread(<span class="string">'messi5.jpg'</span>)</span><br><span class="line">e1 = cv.getTickCount()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">5</span>,<span class="number">49</span>,<span class="number">2</span>):</span><br><span class="line">    img1 = cv.medianBlur(img1,i)</span><br><span class="line">e2 = cv.getTickCount()</span><br><span class="line">t = (e2 - e1)/cv.getTickFrequency()</span><br><span class="line">print( t )</span><br><span class="line"><span class="comment"># Result I got is 0.521107655 seconds</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:您可以使用时间模块执行相同的操作。代替cv.getTickCount，使用time.time（）函数。然后取两次相差。</p>
</blockquote>
<h2 id="OpenCV中的默认优化"><a href="#OpenCV中的默认优化" class="headerlink" title="OpenCV中的默认优化"></a>OpenCV中的默认优化</h2><p>许多OpenCV功能已使用SSE2，AVX等进行了优化。它还包含未优化的代码。因此，如果我们的系统支持这些功能，则应该加以利用（几乎所有现代处理器都支持它们）。默认在编译时启用。因此，OpenCV如果启用了优化代码，则将运行优化代码，否则它将运行未优化的代码。您可以使用<code>cv.useOptimized()</code>来检查是否启用/禁用它，并使用<code>cv.setUseOptimized()</code>来启用/禁用它。让我们看一个简单的例子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># check if optimization is enabled</span></span><br><span class="line">In [<span class="number">5</span>]: cv.useOptimized()</span><br><span class="line">Out[<span class="number">5</span>]: <span class="literal">True</span></span><br><span class="line">In [<span class="number">6</span>]: %timeit res = cv.medianBlur(img,<span class="number">49</span>)</span><br><span class="line"><span class="number">10</span> loops, best of <span class="number">3</span>: <span class="number">34.9</span> ms per loop</span><br><span class="line"><span class="comment"># Disable it</span></span><br><span class="line">In [<span class="number">7</span>]: cv.setUseOptimized(<span class="literal">False</span>)</span><br><span class="line">In [<span class="number">8</span>]: cv.useOptimized()</span><br><span class="line">Out[<span class="number">8</span>]: <span class="literal">False</span></span><br><span class="line">In [<span class="number">9</span>]: %timeit res = cv.medianBlur(img,<span class="number">49</span>)</span><br><span class="line"><span class="number">10</span> loops, best of <span class="number">3</span>: <span class="number">64.1</span> ms per loop</span><br></pre></td></tr></table></figure>

<p>请参阅，优化的中值滤波比未优化的版本快2倍。如果检查其来源，则可以看到中值滤波已进行SIMD优化。因此，您可以使用它在代码顶部启用优化（请记住默认情况下已启用）。</p>
<h2 id="在IPython中评估性能"><a href="#在IPython中评估性能" class="headerlink" title="在IPython中评估性能"></a>在IPython中评估性能</h2><p>有时您可能需要比较两个类似操作的性能。IPython为您提供了一个神奇的命令计时器来执行此操作。它会多次运行代码以获得更准确的结果。同样，它们适用于测量单行代码。</p>
<p>例如，您知道以下哪个加法运算更好，x = 5; y = x ** 2，x = 5; y = x * x，x = np.uint8（[5]）; y = x * x或y = np.square（x）？我们将在IPython shell中使用timeit找到它。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">10</span>]: x = <span class="number">5</span></span><br><span class="line">In [<span class="number">11</span>]: %timeit y=x**<span class="number">2</span></span><br><span class="line"><span class="number">10000000</span> loops, best of <span class="number">3</span>: <span class="number">73</span> ns per loop</span><br><span class="line">In [<span class="number">12</span>]: %timeit y=x*x</span><br><span class="line"><span class="number">10000000</span> loops, best of <span class="number">3</span>: <span class="number">58.3</span> ns per loop</span><br><span class="line">In [<span class="number">15</span>]: z = np.uint8([<span class="number">5</span>])</span><br><span class="line">In [<span class="number">17</span>]: %timeit y=z*z</span><br><span class="line"><span class="number">1000000</span> loops, best of <span class="number">3</span>: <span class="number">1.25</span> us per loop</span><br><span class="line">In [<span class="number">19</span>]: %timeit y=np.square(z)</span><br><span class="line"><span class="number">1000000</span> loops, best of <span class="number">3</span>: <span class="number">1.16</span> us per loop</span><br></pre></td></tr></table></figure>

<p>您可以看到x = 5; y = x * x最快，比Numpy快20倍左右。如果您还考虑阵列的创建，它可能会快100倍。酷吧？<em>（大量开发人员正在研究此问题）</em></p>
<blockquote>
<p>注意:Python标量运算比Numpy标量运算快。因此，对于包含一两个元素的运算，Python标量比Numpy数组要好。当数组大小稍大时，Numpy会占优势。</p>
</blockquote>
<p>我们将再尝试一个示例。这次，我们将比较同一图片的<code>cv.countNonZero()</code>和<code>np.count_nonzero()</code>性能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">35</span>]: %timeit z = cv.countNonZero(img)</span><br><span class="line"><span class="number">100000</span> loops, best of <span class="number">3</span>: <span class="number">15.8</span> us per loop</span><br><span class="line">In [<span class="number">36</span>]: %timeit z = np.count_nonzero(img)</span><br><span class="line"><span class="number">1000</span> loops, best of <span class="number">3</span>: <span class="number">370</span> us per loop</span><br></pre></td></tr></table></figure>

<p>可以看出，OpenCV功能比Numpy功能快25倍。</p>
<blockquote>
<p>注意:通常，OpenCV函数比Numpy函数要快。因此，对于相同的操作，首选OpenCV功能。但是，可能会有例外，尤其是当Numpy处理视图而不是副本时。</p>
</blockquote>
<h2 id="更多IPython魔术命令"><a href="#更多IPython魔术命令" class="headerlink" title="更多IPython魔术命令"></a>更多IPython魔术命令</h2><p>还有其他一些魔术命令可以用来测量性能，性能分析，行性能分析，内存测量等。它们都有很好的文档记录。</p>
<h2 id="性能优化技术"><a href="#性能优化技术" class="headerlink" title="性能优化技术"></a>性能优化技术</h2><p>有几种技术和编码方法可以充分利用Python和Numpy的性能。此处仅记录相关内容，并链接到重要资源。这里要注意的主要事情是，首先尝试以一种简单的方式实现该算法。工作正常后，对其进行概要分析，找到瓶颈并对其进行优化。</p>
<ul>
<li>尽量避免在Python中使用循环，尤其是双/三重循环等。它们本来就很慢。</li>
<li>由于Numpy和OpenCV已针对向量运算进行了优化，因此将算法/代码向量化到最大程度。</li>
<li>利用缓存一致性。</li>
<li>除非需要，否则切勿制作数组的副本。尝试改用视图。阵列复制是一项昂贵的操作。<br>即使执行了所有这些操作后，如果您的代码仍然很慢，或者不可避免地需要使用大循环，请使用Cython等其他库来使其更快。</li>
</ul>

    </div>

    
    
    
        
      
        <div id="reward-container">
  <div>您的支持是对我最大的鼓励</div>
  <button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
        
      
      <div style="display: inline-block">
        <img src="/images/weixin.jpg" alt="陈 建 微信支付">
        <p>微信支付</p>
      </div>
        
      
      <div style="display: inline-block">
        <img src="/images/alipay.jpg" alt="陈 建 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

      
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>陈 建</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://leesin.cc/opencv/OpenCV的核心操作.html" title="OpenCV的核心操作">http://leesin.cc/opencv/OpenCV的核心操作.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li>
</ul>
</div>

      

      <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/opencv/OpenCV中的Gui功能.html" rel="next" title="OpenCV中的Gui功能">
                  <i class="fa fa-chevron-left"></i> OpenCV中的Gui功能
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/opencv/OpenCV中的图像处理.html" rel="prev" title="OpenCV中的图像处理">
                  OpenCV中的图像处理 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/avatar.jpg"
      alt="陈 建">
  <p class="site-author-name" itemprop="name">陈 建</p>
  <div class="site-description motion-element" itemprop="description">当时明月在，曾照彩云归</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">68</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/LeeSinCOOC" title="GitHub &rarr; https://github.com/LeeSinCOOC" rel="noopener" target="_blank"><i class="fa fa-fw fa-GitHub"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:690246265@qq.com" title="E-Mail &rarr; mailto:690246265@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-E-Mail"></i>E-Mail</a>
      </span>
    
  </div>


  <div class="links-of-blogroll motion-element links-of-blogroll-block">
    <div class="links-of-blogroll-title">
      <i class="fa  fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com" title="https://www.baidu.com" rel="noopener" target="_blank">baidu</a>
        </li>
      
    </ul>
  </div>


        </div>
      </div>
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#图像的基本操作"><span class="nav-number">1.</span> <span class="nav-text">图像的基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#目标"><span class="nav-number">1.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#访问和修改像素值"><span class="nav-number">1.2.</span> <span class="nav-text">访问和修改像素值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#访问图像属性"><span class="nav-number">1.3.</span> <span class="nav-text">访问图像属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#图像投资回报率"><span class="nav-number">1.4.</span> <span class="nav-text">图像投资回报率</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分割和合并图像通道"><span class="nav-number">1.5.</span> <span class="nav-text">分割和合并图像通道</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为图像设置边框（填充）"><span class="nav-number">1.6.</span> <span class="nav-text">为图像设置边框（填充）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#图像上的算术运算"><span class="nav-number">2.</span> <span class="nav-text">图像上的算术运算</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#目标-1"><span class="nav-number">2.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#图像加法"><span class="nav-number">2.2.</span> <span class="nav-text">图像加法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#图像融合"><span class="nav-number">2.3.</span> <span class="nav-text">图像融合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#按位运算"><span class="nav-number">2.4.</span> <span class="nav-text">按位运算</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#绩效评估和改进技术"><span class="nav-number">3.</span> <span class="nav-text">绩效评估和改进技术</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#目标-2"><span class="nav-number">3.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用OpenCV衡量性能"><span class="nav-number">3.2.</span> <span class="nav-text">使用OpenCV衡量性能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OpenCV中的默认优化"><span class="nav-number">3.3.</span> <span class="nav-text">OpenCV中的默认优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在IPython中评估性能"><span class="nav-number">3.4.</span> <span class="nav-text">在IPython中评估性能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更多IPython魔术命令"><span class="nav-number">3.5.</span> <span class="nav-text">更多IPython魔术命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#性能优化技术"><span class="nav-number">3.6.</span> <span class="nav-text">性能优化技术</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">陈 建</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.3.0</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  
    <span class="post-meta-divider">|</span>
  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

<script src="/js/utils.js?v=7.3.0"></script><script src="/js/motion.js?v=7.3.0"></script>

<script src="/js/schemes/muse.js?v=7.3.0"></script>



<script src="/js/next-boot.js?v=7.3.0"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>















  <script src="/js/local-search.js?v=7.3.0"></script>














  

  

  


  
  <script src="/js/scrollspy.js?v=7.3.0"></script><script src="/js/post-details.js?v=7.3.0"></script>


</body>
</html>
