<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[page]]></title>
    <url>%2Freading%2F%E5%9F%BA%E4%BA%8EOpenCVh%E5%92%8CYOLO-V3%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%AE%9E%E7%8E%B0.html</url>
    <content type="text"><![CDATA[本文翻译自Deep Learning based Object Detection using YOLOv3 with OpenCV ( Python / C++ ) 本文搬运自：https://blog.csdn.net/qq_27158179/article/details/81915740 基于OpenCV和YOLOv3深度学习的目标检测 从OpenCV 3.4.2开始，我们可以很容易的在OpenCV应用中使用YOLOv3模型（即OpemCV-3.4.2开始支持YOLOv3这网络框架）。 YOLO是什么原理？我们可以把目标检测看成是目标定位和目标识别的结合。 在传统的计算机视觉方法中，采用滑动窗口查找不同区域和大小的目标。因为这是消耗量较大的算法，通常假定目标的纵横比是固定的。 早期的基于深度学习的目标检测算法，如R-CNN和快速R-CNN，采用选择型搜索（Selective Search）来缩小必须测试的边界框的数量（本文的边界框指的是，在预测到疑似所识别到的目标后，在图片上把对象框出的一个矩形）。 另外一种称为Overfeat的方法，通过卷积地计算滑动窗口，以多个尺度扫描了图像。 然后有人提出了快速R-CNN算法，使用Region Proposal Network(RPN)区别将要测试的边界框。通过巧妙的设计，用于目标识别的特征点，也被RPN用于提出潜在的边界框，因此节省了大量的计算。 然而，YOLO使用了完全不同的方法解决目标检测问题。它将图像进行神经网络的一次性正向处理。SSD是另外一种将图像进行神经网络一次性正向处理的方法，但是YOLOv3比SSD实现了更高的精度，同时又较快的运算速度。YOLOv3在M40，TitanX和1080Ti这类GPU上实时效果更好。 让我们看看YOLO如何在一张图片中检测目标。 首先，它把原图按比例平均分解成一张有13x13网格的图片。这169个单元会根据原图的大小而改变。对于一张416x416像素的图片，每个图片单元的大小是32x32像素。处理图片时，会以图片单元为单位，预测单位中的多个边界框。 对于每个边界框，这个网络会计算所包含物体的边界框的置信度，同时计算所包含的目标是属于一个特定类别的可能性大小。 非最大抑制（non-maximum suppression）可以消除低置信度的边界框，以及把同时包围着单个物体的多个高置信度的边界框消除到只剩下一个。 YOLOv3的作者，Joseph Redmon和Ali Farhadi，让YOLOv3比前一代YOLOv2更加精确和快速。YOLOv3在处理多个不同尺寸图片的场合中得到了优化。他们还通过加大了网络，并添加快捷链接将其引入剩余网络来改进网络。 为什么选择OpenCV的YOLO 这里有三个理由。 容易整合到现有的OpenCV程序中：如果应用程序已经使用了OpenCV，并想简单地使用YOLOv3，完全不需要担心Darknet源代码的编译和建立。 OpenCV的CPU版本的运算速度比Darknet+OpenMP快9倍：OpenCV的DNN模块，其CPU运行是十分快的。举个例子，当用了OpenMP的Darknet在CPU上处理一张图片消耗2秒，OpenCV的实现只需要0.22秒。具体请看下面的表格。 支持Python。Darknet是用C语言写的，因此并不支持Python。相反，OpenCV是支持Python的。会有支持Darknet的编程接口。 在Darknet和OpenCV上跑YOLOv3的速度测试下面的表格展示了在Darknet和OpenCV上YOLOv3的性能差距，输入图片的尺寸是416x416。不出所料，GPU版本的Darknet在性能上比其他方式优越。同时，理所当然的Darknet配合OpenMP会好于没有OpenMP的Darknet，因为OpenMP支持多核的CPU。 意外的是，CPU版本的OpenCV在执行DNN的运算速度，是9倍的快过Darknet和OpenML OS Framework CPU/GPU Time(ms)/Frame Linux 16.04 Darknet 12x Intel Core i7-6850K CPU @ 3.60GHz 9370 Linux 16.04 Darknet + OpenMP 12x Intel Core i7-6850K CPU @ 3.60GHz 1942 Linux 16.04 OpenCV [CPU] 12x Intel Core i7-6850K CPU @ 3.60GHz 220 Linux 16.04 Darknet NVIDIA GeForce 1080 Ti GPU 23 macOS DarkNet 2.5 GHz Intel Core i7 CPU 7260 macOS OpenCV [CPU] 2.5 GHz Intel Core i7 CPU 400 采用YOLOv3的目标检测，C++/Python两种语言第1步：下载模型1234cd 到wget安装目录，执行wget https://pjreddie.com/media/files/yolov3.weightswget https://github.com/pjreddie/darknet/blob/master/cfg/yolov3.cfg?raw=true -O ./yolov3.cfgwget https://github.com/pjreddie/darknet/blob/master/data/coco.names?raw=true -O ./coco.names 执行命令后开始下载yolov3.weights文件（包括了提前训练好的网络的权值），和yolov3.cfg文件（包含了网络的配置方式）和coco.names（包括了COCO数据库中使用的80种不同的目标种类名字）。 所以如果是自己训练的模型，也就同样把：权重文件，网络配置文件，标签文件拷贝过来就可以了 第2步：初始化参数YOLOv3算法的预测结果就是边界框。每一个边界框都旁随着一个置信值。第一阶段中，全部低于置信度阀值的都会排除掉。 对剩余的边界框执行非最大抑制算法，以去除重叠的边界框。非最大抑制由一个参数nmsThrehold控制。读者可以尝试改变这个数值，观察输出的边界框的改变。 接下来，设置输入图片的宽度（inpWidth）和高度（inpHeight）。我们设置他们为416，以便对比YOLOv3作者提供的Darknets的C代码。如果想要更快的速度，读者可以把宽度和高度设置为320。如果想要更准确的结果，改变他们到608。 Python代码：12345# Initialize the parametersconfThreshold = 0.5 #Confidence thresholdnmsThreshold = 0.4 #Non-maximum suppression thresholdinpWidth = 416 #Width of network's input imageinpHeight = 416 #Height of network's input image C++代码：12345// Initialize the parametersfloat confThreshold = 0.5; // Confidence thresholdfloat nmsThreshold = 0.4; // Non-maximum suppression thresholdint inpWidth = 416; // Width of network's input imageint inpHeight = 416; // Height of network's input image 第3步：读取模型和类别文件coco.names包含了训练好的模型能识别的所有目标名字。我们读出各个类别的名字。 接着，我们读取了网络，其包含两个部分： yolov3.weights: 预训练得到的权重。 yolov3.cfg：配置文件 我们把DNN的后端设置为OpenCV，目标设置为CPU。可以通过使cv.dnn.DNN_TARGET_OPENCL置为GPU，尝试设定偏好的运行目标为GPU。但是要记住当前的OpenCV版本只在Intel的GPU上测试，如果没有Intel的GPU则程序会自动设置为CPU。 Python:12345678910111213# Load names of classesclassesFile = "coco.names";classes = Nonewith open(classesFile, 'rt') as f: classes = f.read().rstrip('\n').split('\n') # Give the configuration and weight files for the model and load the network using them.modelConfiguration = "yolov3.cfg";modelWeights = "yolov3.weights"; net = cv.dnn.readNetFromDarknet(modelConfiguration, modelWeights)net.setPreferableBackend(cv.dnn.DNN_BACKEND_OPENCV)net.setPreferableTarget(cv.dnn.DNN_TARGET_CPU) C++:1234567891011121314// Load names of classesstring classesFile = "coco.names";ifstream ifs(classesFile.c_str());string line;while (getline(ifs, line)) classes.push_back(line); // Give the configuration and weight files for the modelString modelConfiguration = "yolov3.cfg";String modelWeights = "yolov3.weights"; // Load the networkNet net = readNetFromDarknet(modelConfiguration, modelWeights);net.setPreferableBackend(DNN_BACKEND_OPENCV);net.setPreferableTarget(DNN_TARGET_CPU); 第4步：读取输入这一步我们读取图像，视频流或者网络摄像头。另外，我们也使用Videowriter（OpenCV里的一个类）以视频方式保存带有输出边界框的每一帧图片。 Python:123456789101112131415161718192021222324252627outputFile = "yolo_out_py.avi"if (args.image): # Open the image file if not os.path.isfile(args.image): print("Input image file ", args.image, " doesn't exist") sys.exit(1) cap = cv.VideoCapture(args.image) outputFile = args.image[:-4]+'_yolo_out_py.jpg'elif (args.video): # Open the video file if not os.path.isfile(args.video): print("Input video file ", args.video, " doesn't exist") sys.exit(1) cap = cv.VideoCapture(args.video) outputFile = args.video[:-4]+'_yolo_out_py.avi'else: # Webcam input cap = cv.VideoCapture(0) # Get the video writer initialized to save the output videoif (not args.image): vid_writer = cv.VideoWriter ( outputFile, cv.VideoWriter_fourcc('M','J','P','G'), 30, (round(cap.get(cv.CAP_PROP_FRAME_WIDTH)), round(cap.get(cv.CAP_PROP_FRAME_HEIGHT)),) ) C++:12345678910111213141516171819202122232425262728293031323334353637outputFile = "yolo_out_cpp.avi";if (parser.has("image"))&#123; // Open the image file str = parser.get&lt;String&gt;("image"); ifstream ifile(str); if (!ifile) throw("error"); cap.open(str); str.replace(str.end()-4, str.end(), "_yolo_out.jpg"); outputFile = str;&#125;else if (parser.has("video"))&#123; // Open the video file str = parser.get&lt;String&gt;("video"); ifstream ifile(str); if (!ifile) throw("error"); cap.open(str); str.replace(str.end()-4, str.end(), "_yolo_out.avi"); outputFile = str;&#125;// Open the webcaomelse cap.open(parser.get&lt;int&gt;("device")); // Get the video writer initialized to save the output videoif (!parser.has("image")) &#123; video.open( outputFile, VideoWriter::fourcc('M','J','P','G'), 28, Size( cap.get(CAP_PROP_FRAME_WIDTH), cap.get(CAP_PROP_FRAME_HEIGHT) ) );&#125; 第5步：处理每一帧输入到神经网络的图像需要以一种叫bolb的格式保存。 读取了输入图片或者视频流的一帧图像后，这帧图像需要经过bolbFromImage()函数处理为神经网络的输入类型bolb。在这个过程中，图像像素以一个1/255的比例因子，被缩放到0到1之间。同时，图像在不裁剪的情况下，大小调整到416x416。注意我们没有降低图像平均值，因此传递[0,0,0]到函数的平均值输入，保持swapRB参数到默认值1。 输出的bolb传递到网络，经过网络正向处理，网络输出了所预测到的一个边界框清单。这些边界框通过后处理，滤除了低置信值的。我们随后再详细的说明后处理的步骤。我们在每一帧的左上方打印出了推断时间。伴随着最后的边界框的完成，图像保存到硬盘中，之后可以作为图像输入或者通过Videowriter作为视频流输入。 Python：1234567891011121314151617181920212223242526272829303132333435363738394041424344while cv.waitKey(1) &lt; 0: # get frame from the video hasFrame, frame = cap.read() # Stop the program if reached end of video if not hasFrame: print("Done processing !!!") print("Output file is stored as ", outputFile) cv.waitKey(3000) break # Create a 4D blob from a frame. blob = cv.dnn.blobFromImage( frame, 1/255, (inpWidth, inpHeight), [0,0,0], 1, crop=False) # Sets the input to the network net.setInput(blob) # Runs the forward pass to get output of the output layers outs = net.forward(getOutputsNames(net)) # Remove the bounding boxes with low confidence postprocess(frame, outs) # Put efficiency information. The function getPerfProfile returns the # overall time for inference(t) and the timings for each of the layers(in layersTimes) t, _ = net.getPerfProfile() label = 'Inference time: %.2f ms' % ( t * 1000.0 / cv.getTickFrequency()) cv.putText(frame, label, (0, 15), cv.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 255)) # Write the frame with the detection boxes if (args.image): cv.imwrite(outputFile, frame.astype(np.uint8)); else: vid_writer.write(frame.astype(np.uint8)) c++:12345678910111213141516171819202122232425262728293031323334353637383940414243// Process frames.while (waitKey(1) &lt; 0)&#123; // get frame from the video cap &gt;&gt; frame; // Stop the program if reached end of video if (frame.empty()) &#123; cout &lt;&lt; "Done processing !!!" &lt;&lt; endl; cout &lt;&lt; "Output file is stored as " &lt;&lt; outputFile &lt;&lt; endl; waitKey(3000); break; &#125; // Create a 4D blob from a frame. blobFromImage(frame, blob, 1/255.0, cvSize(inpWidth, inpHeight), Scalar(0,0,0), true, false); //Sets the input to the network net.setInput(blob); // Runs the forward pass to get output of the output layers vector&lt;Mat&gt; outs; net.forward(outs, getOutputsNames(net)); // Remove the bounding boxes with low confidence postprocess(frame, outs); // Put efficiency information. The function getPerfProfile returns the // overall time for inference(t) and the timings for each of the layers(in layersTimes) vector&lt;double&gt; layersTimes; double freq = getTickFrequency() / 1000; double t = net.getPerfProfile(layersTimes) / freq; string label = format("Inference time for a frame : %.2f ms", t); putText(frame, label, Point(0, 15), FONT_HERSHEY_SIMPLEX, 0.5, Scalar(0, 0, 255)); // Write the frame with the detection boxes Mat detectedFrame; frame.convertTo(detectedFrame, CV_8U); if (parser.has("image")) imwrite(outputFile, detectedFrame); else video.write(detectedFrame); &#125; 现在，让我们详细分析一下上面调用的函数。 第5a步：得到输出层的名字OpenCV的网络类中的前向功能需要结束层，直到它在网络中运行。因为我们需要运行整个网络，所以我们需要识别网络中的最后一层。我们通过使用getUnconnectedOutLayers()获得未连接的输出层的名字，该层基本就是网络的最后层。然后我们运行前向网络，得到输出，如前面的代码片段（net.forward(getOutputsNames(net))）。 python:1234567# Get the names of the output layersdef getOutputsNames(net): # Get the names of all the layers in the network layersNames = net.getLayerNames() # Get the names of the output layers, i.e. the layers with unconnected outputs return [layersNames[i[0] - 1] for i in net.getUnconnectedOutLayers()] C++:12345678910111213141516171819// Get the names of the output layersvector&lt;String&gt; getOutputsNames(const Net&amp; net)&#123; static vector&lt;String&gt; names; if (names.empty()) &#123; //Get the indices of the output layers, i.e. the layers with unconnected outputs vector&lt;int&gt; outLayers = net.getUnconnectedOutLayers(); //get the names of all the layers in the network vector&lt;String&gt; layersNames = net.getLayerNames(); // Get the names of the output layers in names names.resize(outLayers.size()); for (size_t i = 0; i &lt; outLayers.size(); ++i) names[i] = layersNames[outLayers[i] - 1]; &#125; return names;&#125; 第5b步：后处理网络输出网络输出的每个边界框都分别由一个包含着类别名字和5个元素的向量表示。 头四个元素代表center_x, center_y, width和height。第五个元素表示包含着目标的边界框的置信度。 其余的元素是和每个类别（如目标种类）有关的置信度。边界框分配给最高分数对应的那一种类。 一个边界框的最高分数也叫做它的置信度（confidence）。如果边界框的置信度低于规定的阀值，算法上不再处理这个边界框。 置信度大于或等于置信度阀值的边界框，将进行非最大抑制。这会减少重叠的边界框数目。 Python:12345678910111213141516171819202122232425262728293031323334353637383940# Remove the bounding boxes with low confidence using non-maxima suppressiondef postprocess(frame, outs): frameHeight = frame.shape[0] frameWidth = frame.shape[1] classIds = [] confidences = [] boxes = [] # Scan through all the bounding boxes output from the network and keep only the # ones with high confidence scores. Assign the box's class label as the class with the highest score. classIds = [] confidences = [] boxes = [] for out in outs: for detection in out: scores = detection[5:] classId = np.argmax(scores) confidence = scores[classId] if confidence &gt; confThreshold: center_x = int(detection[0] * frameWidth) center_y = int(detection[1] * frameHeight) width = int(detection[2] * frameWidth) height = int(detection[3] * frameHeight) left = int(center_x - width / 2) top = int(center_y - height / 2) classIds.append(classId) confidences.append(float(confidence)) boxes.append([left, top, width, height]) # Perform non maximum suppression to eliminate redundant overlapping boxes with # lower confidences. indices = cv.dnn.NMSBoxes(boxes, confidences, confThreshold, nmsThreshold) for i in indices: i = i[0] box = boxes[i] left = box[0] top = box[1] width = box[2] height = box[3] drawPred(classIds[i], confidences[i], left, top, left + width, top + height) c++:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// Remove the bounding boxes with low confidence using non-maxima suppressionvoid postprocess(Mat&amp; frame, const vector&lt;Mat&gt;&amp; outs)&#123; vector&lt;int&gt; classIds; vector&lt;float&gt; confidences; vector&lt;Rect&gt; boxes; for (size_t i = 0; i &lt; outs.size(); ++i) &#123; // Scan through all the bounding boxes output from the network and keep only the // ones with high confidence scores. Assign the box's class label as the class // with the highest score for the box. float* data = (float*)outs[i].data; for (int j = 0; j &lt; outs[i].rows; ++j, data += outs[i].cols) &#123; Mat scores = outs[i].row(j).colRange(5, outs[i].cols); Point classIdPoint; double confidence; // Get the value and location of the maximum score minMaxLoc(scores, 0, &amp;confidence, 0, &amp;classIdPoint); if (confidence &gt; confThreshold) &#123; int centerX = (int)(data[0] * frame.cols); int centerY = (int)(data[1] * frame.rows); int width = (int)(data[2] * frame.cols); int height = (int)(data[3] * frame.rows); int left = centerX - width / 2; int top = centerY - height / 2; classIds.push_back(classIdPoint.x); confidences.push_back((float)confidence); boxes.push_back(Rect(left, top, width, height)); &#125; &#125; &#125; // Perform non maximum suppression to eliminate redundant overlapping boxes with // lower confidences vector&lt;int&gt; indices; NMSBoxes(boxes, confidences, confThreshold, nmsThreshold, indices); for (size_t i = 0; i &lt; indices.size(); ++i) &#123; int idx = indices[i]; Rect box = boxes[idx]; drawPred(classIds[idx], confidences[idx], box.x, box.y, box.x + box.width, box.y + box.height, frame); &#125;&#125; 非最大抑制由参数nmsThreshold控制。如果nmsThreshold设置太少，比如0.1，我们可能检测不到相同或不同种类的重叠目标。如果设置得太高，比如1，可能出现一个目标有多个边界框包围。 第5c步：画出计算得到的边界框 最后，经过非最大抑制后，得到了边界框。我们把边界框在输入帧上画出，并标出种类名和置信值。 Python: 最后，经过非最大抑制后，得到了边界框。我们把边界框在输入帧上画出，并标出种类名和置信值。 1234567891011121314151617# Draw the predicted bounding boxdef drawPred(classId, conf, left, top, right, bottom): # Draw a bounding box. cv.rectangle(frame, (left, top), (right, bottom), (0, 0, 255)) label = '%.2f' % conf # Get the label for the class name and its confidence if classes: assert(classId &lt; len(classes)) label = '%s:%s' % (classes[classId], label) #Display the label at the top of the bounding box labelSize, baseLine = cv.getTextSize( label, cv.FONT_HERSHEY_SIMPLEX, 0.5, 1) top = max(top, labelSize[1]) cv.putText(frame, label, (left, top), cv.FONT_HERSHEY_SIMPLEX, 0.5, (255,255,255)) c++:12345678910111213141516171819// Draw the predicted bounding boxvoid drawPred(int classId, float conf, int left, int top, int right, int bottom, Mat&amp; frame)&#123; //Draw a rectangle displaying the bounding box rectangle(frame, Point(left, top), Point(right, bottom), Scalar(0, 0, 255)); //Get the label for the class name and its confidence string label = format("%.2f", conf); if (!classes.empty()) &#123; CV_Assert(classId &lt; (int)classes.size()); label = classes[classId] + ":" + label; &#125; //Display the label at the top of the bounding box int baseLine; Size labelSize = getTextSize(label, FONT_HERSHEY_SIMPLEX, 0.5, 1, &amp;baseLine); top = max(top, labelSize.height); putText(frame, label, Point(left, top), FONT_HERSHEY_SIMPLEX, 0.5, Scalar(255,255,255)); 附上Python完整代码，方便搬运123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181######################## 使用示例 ################################ python3 object_detection_yolo.py --video=run.mp4 #### python3 object_detection_yolo.py --image=bird.jpg ################################################################import cv2 as cvimport argparseimport sysimport numpy as npimport os.path# Initialize the parametersconfThreshold = 0.5 #Confidence thresholdnmsThreshold = 0.4 #Non-maximum suppression thresholdinpWidth = 416 #Width of network's input imageinpHeight = 416 #Height of network's input imageparser = argparse.ArgumentParser( description='Object Detection using YOLO in OPENCV')parser.add_argument('--image', help='Path to image file.')parser.add_argument('--video', help='Path to video file.')args = parser.parse_args() # Load names of classesclassesFile = "voc_MLH.names"classes = Nonewith open(classesFile, 'rt') as f: classes = f.read().rstrip('\n').split('\n')# Give the configuration and weight files for the model and load the network using them.modelConfiguration = "yolov3.cfg"modelWeights = "yolov3.weights"net = cv.dnn.readNetFromDarknet(modelConfiguration, modelWeights)#net.setPreferableBackend(cv.dnn.DNN_BACKEND_OPENCV)#net.setPreferableTarget(cv.dnn.DNN_TARGET_CPU)# Get the names of the output layersdef getOutputsNames(net): # Get the names of all the layers in the network layersNames = net.getLayerNames() # Get the names of the output layers, i.e. the layers with unconnected outputs return [layersNames[i[0] - 1] for i in net.getUnconnectedOutLayers()]# Draw the predicted bounding boxdef drawPred(classId, conf, left, top, right, bottom): # Draw a bounding box. cv.rectangle( frame, (left, top), (right, bottom), (255, 178, 50), 3) label = '%.2f' % conf # Get the label for the class name and its confidence if classes: assert(classId &lt; len(classes)) label = '%s:%s' % (classes[classId], label) #Display the label at the top of the bounding box labelSize, baseLine = cv.getTextSize( label, cv.FONT_HERSHEY_SIMPLEX, 0.5, 1) top = max(top, labelSize[1]) cv.rectangle( frame, (left, top - round(3.5*labelSize[1])), (left + round(3.5*labelSize[0]), top + baseLine), (255, 255, 255), cv.FILLED) cv.putText(frame, label, (left, top), cv.FONT_HERSHEY_SIMPLEX, 0.75, (0,0,0), 1)# Remove the bounding boxes with low confidence using non-maxima suppressiondef postprocess(frame, outs): frameHeight = frame.shape[0] frameWidth = frame.shape[1] # Scan through all the bounding boxes output from the network and keep only the # ones with high confidence scores. Assign the box's class label as the class with the highest score. classIds = [] confidences = [] boxes = [] for out in outs: for detection in out: scores = detection[5:] classId = np.argmax(scores) confidence = scores[classId] if confidence &gt; confThreshold: center_x = int(detection[0] * frameWidth) center_y = int(detection[1] * frameHeight) width = int(detection[2] * frameWidth) height = int(detection[3] * frameHeight) left = int(center_x - width / 2) top = int(center_y - height / 2) classIds.append(classId) confidences.append(float(confidence)) boxes.append([left, top, width, height]) # Perform non maximum suppression to eliminate redundant overlapping boxes with # lower confidences. indices = cv.dnn.NMSBoxes( boxes, confidences, confThreshold, nmsThreshold) for i in indices: i = i[0] box = boxes[i] left = box[0] top = box[1] width = box[2] height = box[3] drawPred( classIds[i], confidences[i], left, top, left + width, top + height)# Process inputswinName = 'Deep learning object detection in OpenCV'cv.namedWindow(winName, cv.WINDOW_NORMAL)outputFile = "yolo_out_py.avi"if (args.image): # Open the image file if not os.path.isfile(args.image): print("Input image file ", args.image, " doesn't exist") sys.exit(1) cap = cv.VideoCapture(args.image) outputFile = args.image[:-4]+'_out.jpg'elif (args.video): # Open the video file if not os.path.isfile(args.video): print("Input video file ", args.video, " doesn't exist") sys.exit(1) cap = cv.VideoCapture(args.video) outputFile = args.video[:-4]+'_yolo_out_py.avi'else: # Webcam input cap = cv.VideoCapture(0)# Get the video writer initialized to save the output videoif (not args.image): vid_writer = cv.VideoWriter(outputFile, cv.VideoWriter_fourcc('M','J','P','G'), 30, (round(cap.get(cv.CAP_PROP_FRAME_WIDTH)),round(cap.get(cv.CAP_PROP_FRAME_HEIGHT))))while cv.waitKey(1) &lt; 0: # get frame from the video hasFrame, frame = cap.read() # Stop the program if reached end of video if not hasFrame: print("Done processing !!!") print("Output file is stored as ", outputFile) cv.waitKey(3000) # Release device cap.release() break # Create a 4D blob from a frame. blob = cv.dnn.blobFromImage( frame, 1/255, (inpWidth, inpHeight), [0,0,0], 1, crop=False) # Sets the input to the network net.setInput(blob) # Runs the forward pass to get output of the output layers outs = net.forward(getOutputsNames(net)) # Remove the bounding boxes with low confidence postprocess(frame, outs) # Put efficiency information. The function getPerfProfile returns the overall time for inference(t) and the timings for each of the layers(in layersTimes) t, _ = net.getPerfProfile() label = 'Inference time: %.2f ms' % ( t * 1000.0 / cv.getTickFrequency()) cv.putText(frame, label, (0, 15), cv.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 255)) # Write the frame with the detection boxes if (args.image): cv.imwrite(outputFile, frame.astype(np.uint8)) else: vid_writer.write(frame.astype(np.uint8)) cv.imshow(winName, frame) 扩展内容OpenCV自3.1版本其就在contrib中加入了DNN模块 该DNN模块除了libprotobuf，不依赖任何第三方库；并且libprotobuf已经包含在了OpenCV的ThirdParty，安装OpenCV时会一并安装 目前，该DNN模块支持加载训练好的模型 支持的深度学习库： Caffe 1 TensorFlow Torch/PyTorch 主要的层及函数： AbsVal（caffe/layers/absval_layer.hpp这一层比较简单：主要就是求绝对值） AveragePooling（平均值池化） BatchNormalization（就像激活函数层、卷积层、全连接层、池化层一样，BN也属于网络的一层；在网络中间层数据做一个归一化处理） Concatenation（Caffe中通过Concatenation层，可以把多个的blobs链接成一个blob） Convolution (including dilated convolution) Crop Deconvolution, a.k.a. transposed convolution or full convolution DetectionOutput (SSD-specific layer) Dropout Eltwise (+, *, max)（caffe提供的按元素操作层。它支持3种基本操作：PROD按元素乘积；SUM按元素求和；MAX保存最大元素 ） Flatten（Caffe中Flattening层是把一个输入的大小为n * c * h * w变成一个简单的向量，其大小为 n * (chw) * 1 * 1） FullyConnected LRN（Local Response Normalization，caffe中LRN是对一个局部的输入区域进行的归一化） LSTM MaxPooling（最大池化） MaxUnpooling MVN NormalizeBBox (SSD-specific layer) Padding Permute Power PReLU (including ChannelPReLU with channel-specific slopes) PriorBox (SSD-specific layer) ReLU RNN Scale Shift Sigmoid Slice（Caffe中Slice layer 的作用是将bottom按照需要分解成多个tops） Softmax（激活函数） Split（Caffe中Splitting层可以把一个输入blob分离成多个输出blobs） TanH（激活函数） 一些已经经过测试的网络： AlexNet GoogLeNet v1 (also referred to as Inception-5h) ResNet-34/50/… SqueezeNet v1.1 VGG-based FCN (semantical segmentation network) ENet (lightweight semantical segmentation network) VGG-based SSD (object detection network) MobileNet-based SSD (light-weight object detection network 官方示例]]></content>
  </entry>
  <entry>
    <title><![CDATA[1.tensorflow介绍]]></title>
    <url>%2Ftensorflow%2F1.tensorflow%E4%BB%8B%E7%BB%8D.html</url>
    <content type="text"><![CDATA[#TensorFlow是一个基于数据流编程（dataflow programming）的符号数学系统，被广泛应用于各类机器学习（machine learning）算法的编程实现，其前身是谷歌的神经网络算法库DistBelief 谷歌出品，必属精品。不用介绍，学就完事儿了 ##组件与工作原理###核心组件分布式TensorFlow的核心组件（core runtime）包括：分发中心（distributed master）、执行器（dataflow executor/worker service）、内核应用（kernel implementation）和最底端的设备层（device layer）/网络层（networking layer） ####分发中心从输入的数据流图中剪取子图（subgraph），将其划分为操作片段并启动执行器。分发中心处理数据流图时会进行预设定的操作优化，包括公共子表达式消去（common subexpression elimination）、常量折叠（constant folding）等 ####执行器负责图操作（graph operation）在进程和设备中的运行、收发其它执行器的结果。分布式TensorFlow拥有参数器（parameter server）以汇总和更新其它执行器返回的模型参数。执行器在调度本地设备时会选择进行并行计算和GPU加速 ####内核应用负责单一的图操作，包括数学计算、数组操作（array manipulation）、控制流（control flow）和状态管理操作（state management operations）。内核应用使用Eigen执行张量的并行计算、cuDNN库等执行GPU加速、gemmlowp执行低数值精度计算，此外用户可以在内核应用中注册注册额外的内核（fused kernels）以提升基础操作，例如激励函数和其梯度计算的运行效率 单进程版本的TensorFlow没有分发中心和执行器，而是使用特殊的会话应用（Session implementation）联系本地设备。TensorFlow的C语言API是核心组件和用户代码的分界，其它组件/API均通过C语言API与核心组件进行交互 ###低阶API1.张量（tf.Tensor） 2.变量（tf.Variable） 3.数据流图（tf.Graph） 4.会话（tf.Session） 5.保存和恢复对张量的保存和恢复使用tf.train.Saver 6.使用检查点工具tf.python.tools.inspect_checkpoint可以查看文件中保存的张量 ###高阶API ####EstimatorsEstimators是TensorFlow自带的高阶神经网络API Estimators封装了神经网络的训练、评估、预测、导出等操作 工作流程如下： 1.建立数据集导入函数：可以使用TensorFlow的数据导入工具tf.data.Dataset或从NumPy数组创建数据集导入函数。 2.定义特征列：特征列（tf.feature_column）包含了训练数据的特征名称、特征类型和输入预处理操作。 3.调出预创建的Estimator模型：可用的模型包括基础统计学（baseline）、梯度提升决策树（boosting desicion tree）和深度神经网络的回归、分类器。调出模型后需提供输入特征列、检查点路径和有关模型参数（例如神经网络的隐含层结构）。 4.训练和评估模型：所有预创建模型都包含train和evaluate接口用于学习和评估。 ####KerasKeras是一个支持TensorFlow、Thenao和Microsoft-CNTK的第三方高阶神经网络API ####Datatf.data是TensorFlow中进行数据管理的高阶API tf.data可用于构建和优化大规机器学习的输入管道（input pipline），提升TensorFlow性能。一个典型的输入管道包含三个部分 1.提取（Extract）：从本地或云端的数据存储点读取原始数据 2.转化（Transform）：使用计算设备（通常为CPU）对数据进行解析和后处理，例如解压缩、洗牌（shuffling）、打包（batching）等 3.加载（Load）：在运行机器学习算法的高性能计算设备（GPU和TPU）加载经过后处理的数据 加速器CPU和GPU设备 ###加速器1.CPU和GPU设备 2.TPU设备 3.设备管理（tf.device） ###优化器 #####模型优化工具Tensorflow提供了模型优化工具（Model Optimization Toolkit）对模型的尺度、响应时间和计算开销进行优化 [51] 。模型优化工具可以减少模型参数的使用量（pruning）、对模型精度进行量化（quantization）和改进模型的拓扑结构，适用于将模型部署到终端设备，或在有硬件局限时运行模型，因此有很多优化方案是TensorFlow Lite项目的一部分 #####XLA线性代数加速器（Accelerated Linear Algebra, XLA）是一个特殊的编译器，用于优化TensorFlow中的线性代数计算，其目标是优化内存使用，提升TensorFlow的运行速度和跨平台，尤其是移动终端的可移植性 ###可视化工具TensorFlow拥有自带的可视化工具TensorBoard，TensorBoard具有展示数据流图、绘制分析图、显示附加数据等功能 ###调试程序TensorFlow团队开发了专用的调试模块TFDBG，该模块可以在学习和预测时查看会话中数据流图的内部结构和状态 ###部署TensorFlow支持在一个或多个系统下使用多个设备并部署分布式服务器（distributed server）和服务器集群（cluster）。tf.train.Server.create_local_server可在本地构建简单的分布式服务器]]></content>
      <categories>
        <category>TensorFlow教程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[常用LaTex语法]]></title>
    <url>%2Freading%2F%E5%B8%B8%E7%94%A8LaTex%E8%AF%AD%E6%B3%95.html</url>
    <content type="text"><![CDATA[LaTex语法公式前后都加上两个$$符号123456$$LaTex$$$$x=\frac&#123;-b\pm\sqrt&#123;b^2-4ac&#125;&#125;&#123;2a&#125;,y=\frac&#123;-b\pm\sqrt&#123;b^2-4ac&#125;&#125;&#123;2a&#125;$$ $$x=\frac{-b\pm\sqrt{b^2-4ac}}{2a},y=\frac{-b\pm\sqrt{b^2-4ac}}{2a}$$ 行符号为 “\”12345$$x=\frac&#123;-b\pm\sqrt&#123;b^2-4ac&#125;&#125;&#123;2a&#125;,\\ y=\frac&#123;-b\pm\sqrt&#123;b^2-4ac&#125;&#125;&#123;2a&#125;$$ $$x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}\y=\frac{-b\pm\sqrt{b^2-4ac}}{2a}$$ 基本运算乘法：x \times y$$x \times y$$ 乘方：2^{3x}$$2^{3x}$$ 平方根：\sqrt {x + y}$$\sqrt {x + y}$$ 除法：x \div y$$x \div y$$ 分数：\frac {x}{y}$$\frac {x}{y}$$ 异或：\oplus$$\oplus$$ 小于或等于：x \leq y$$x \leq y$$ 大于或等于：x \geq y$$x \geq y$$ 不等于：x \neq y$$x \neq y$$ 向下取整：\lfloor x \rfloor$$\lfloor 32.443 \rfloor$$ 向上取整：\lceil x \rceil$$\lceil 20.444 \rceil$$ 求和：\sum\limits_{x = 1}^{n} 7x$$\sum\limits_{x = 1}^{n} 7x$$ 积分：\int_{0}^{\frac{\pi}{2}} \sin(x)$$\int_{0}^{\frac{\pi}{2}} \sin(x)$$ 集合符号：A \in B$$A \in B$$ 不属于：A \notin B$$A \notin B$$ 子集：\subet \sub$$A \sube B\A \sub B$$ 希腊字母\alpha$$\alpha$$ \beta$$\beta$$ theta$$\theta$$ \pi$$\pi$$ 向量矩阵向量：\vec{v}$$\vec{v}$$ 简单Matrix：$$ \begin{matrix} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ 7 &amp; 8 &amp; 9 \end{matrix} \tag{1} $$$$\begin{matrix} 1 &amp; 2 &amp; 3 \ 4 &amp; 5 &amp; 6 \ 7 &amp; 8 &amp; 9 \end{matrix} \tag{1}$$ 带括号的Matrix可以给矩阵加上括号，加括号的方式有很多，大致可分为两种：使用\left ... \right 或者把公式命令中的matrix 改成 pmatrix、bmatrix、Bmatrix、vmatrix、Vmatrix等。 使用\left … \right 123456789$$ \left\&#123; \begin&#123;matrix&#125; 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ 7 &amp; 8 &amp; 9 \end&#123;matrix&#125; \right\&#125; \tag&#123;2&#125;$$ $$\left{ \begin{matrix} 1 &amp; 2 &amp; 3 \ 4 &amp; 5 &amp; 6 \ 7 &amp; 8 &amp; 9 \end{matrix} \right} \tag{2}$$ 123456789$$ \left[ \begin&#123;matrix&#125; 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ 7 &amp; 8 &amp; 9 \end&#123;matrix&#125; \right] \tag&#123;3&#125;$$ $$\left[ \begin{matrix} 1 &amp; 2 &amp; 3 \ 4 &amp; 5 &amp; 6 \ 7 &amp; 8 &amp; 9 \end{matrix} \right] \tag{3}$$ 1234567$$ \begin&#123;bmatrix&#125; 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ 7 &amp; 8 &amp; 9 \end&#123;bmatrix&#125; \tag&#123;4&#125;$$ $$\begin{bmatrix} 1 &amp; 2 &amp; 3 \ 4 &amp; 5 &amp; 6 \ 7 &amp; 8 &amp; 9 \end{bmatrix} \tag{4}$$ 1234567$$ \begin&#123;Bmatrix&#125; 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ 7 &amp; 8 &amp; 9 \end&#123;Bmatrix&#125; \tag&#123;5&#125;$$ $$\begin{Bmatrix} 1 &amp; 2 &amp; 3 \ 4 &amp; 5 &amp; 6 \ 7 &amp; 8 &amp; 9 \end{Bmatrix} \tag{5}$$ 如果矩阵元素太多，可以使用\cdots ⋯⋯ \ddots ⋱⋱ \vdots ⋮⋮ 等省略符号来定义矩阵。 12345678910$$\left[\begin&#123;matrix&#125; 1 &amp; 2 &amp; \cdots &amp; 4 \\ 7 &amp; 6 &amp; \cdots &amp; 5 \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ 8 &amp; 9 &amp; \cdots &amp; 0 \\\end&#123;matrix&#125;\right]$$ $$\left[\begin{matrix} 1 &amp; 2 &amp; \cdots &amp; 4 \ 7 &amp; 6 &amp; \cdots &amp; 5 \ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \ 8 &amp; 9 &amp; \cdots &amp; 0 \\end{matrix}\right]$$ 带参数的Matrix比如写增广矩阵，可能需要最右边一列单独考虑。可以用array命令来处理： 12345678$$ \left[ \begin&#123;array&#125;&#123;cc|c&#125; 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \end&#123;array&#125;\right] \tag&#123;7&#125;$$ $$\left[ \begin{array}{cc|c} 1 &amp; 2 &amp; 3 \ 4 &amp; 5 &amp; 6 \end{array}\right] \tag{7}$$ 其中\begin{array}{cc|c}中的c表示居中对齐元素,|用来作为分割列的符号。]]></content>
      <categories>
        <category>一些笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[常用Markdown语法]]></title>
    <url>%2Freading%2F%E5%B8%B8%E7%94%A8Markdown%E8%AF%AD%E6%B3%95.html</url>
    <content type="text"><![CDATA[MarkdownMarkdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。Markdown 编写的文档后缀为 .md, .markdown Markdown 标题123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 Markdown 段落Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车 字体Markdown 可以使用以下几种字体： 123456*斜体文本*_斜体文本_**粗体文本**__粗体文本__***粗斜体文本***___粗斜体文本___ 分隔线你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： 123456789**** * ******- - ----------- 删除线如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下： 1~~baidu~~ baidu ###下划线下划线可以通过 HTML 的 &lt; u &gt; 标签来实现： 1&lt;u&gt;带下划线文本&lt;/u&gt; 带下划线文本 ###脚注脚注是对文本的补充说明。Markdown 脚注的格式如下: 1[^要注明的文本] ##Markdown 列表Markdown 支持有序列表和无序列表。无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记： 123456789101112* 第一项* 第二项* 第三项+ 第一项+ 第二项+ 第三项- 第一项- 第二项- 第三项 有序列表使用数字并加上 . 号来表示，如： 1231. 第一项2. 第二项3. 第三项 列表嵌套列表嵌套只需在子列表中的选项添加四个空格即可： 1234561. 第一项： - 第一项嵌套的第一个元素 - 第一项嵌套的第二个元素2. 第二项： - 第二项嵌套的第一个元素 - 第二项嵌套的第一个元素 Markdown 区块Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号： 1&gt; 区块引用 引用 Markdown 代码###函数或片段代码用反引号把它包起来（`），例如： 1`printf()` 函数 print()函数 ###代码区块代码区块使用 4 个空格或者一个制表符（Tab 键） 12def hello(): print('hello') ##Markdown 链接链接使用方法如下： 12345[链接名称](链接地址)或者&lt;链接地址&gt; 这是百度链接：百度 ##Markdown 图片Markdown 图片语法格式如下： 123![alt 属性文本](图片地址)![alt 属性文本](图片地址 "可选标题") Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 标签 1&lt;img src="logo.png" width="50%"&gt; ##Markdown 表格Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。语法格式如下： 1234| 表头 | 表头 || ---- | ---- || 单元格 | 单元格 || 单元格 | 单元格 | 表头 表头 单元格 单元格 单元格 单元格 ###对齐方式 我们可以设置表格的对齐方式： -: 设置内容和标题栏居右对齐 :- 设置内容和标题栏居左对齐 :-: 设置内容和标题栏居中对齐 ##Markdown 高级技巧 ###支持的 HTML 元素不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。 目前支持的 HTML 元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt; 1使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑 使用 Ctrl+Alt+Del 重启电脑 ###转义Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符： 12**文本加粗** \*\* 正常显示星号 \*\* Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： 123456789101112\ 反斜线` 反引号* 星号_ 下划线&#123;&#125; 花括号[] 方括号() 小括号# 井字号+ 加号- 减号. 英文句点! 感叹号 ###公式当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。 123$$$$]]></content>
      <categories>
        <category>一些笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[20.Python的面对对象]]></title>
    <url>%2Fpython%2F20.Python%E7%9A%84%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1.html</url>
    <content type="text"><![CDATA[书接上文Python 面向对象Python从设计之初就已经是一门面向对象的语言，正因为如此，在Python中创建一个类和对象是很容易的。本章节我们将详细介绍Python的面向对象编程。如果你以前没有接触过面向对象的编程语言，那你可能需要先了解一些面向对象语言的一些基本特征，在头脑里头形成一个基本的面向对象的概念，这样有助于你更容易的学习Python的面向对象编程。 接下来我们先来简单的了解下面向对象的一些基本特征。 面向对象技术简介 类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。 数据成员：类变量或者实例变量, 用于处理类及其实例对象的相关的数据。 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。 局部变量：定义在方法中的变量，只作用于当前实例的类。 实例变量：在类的声明中，属性是用变量来表示的。这种变量就称为实例变量，是在类声明的内部但是在类的其他成员方法之外声明的。 继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。 实例化：创建一个类的实例，类的具体对象。 方法：类中定义的函数。 对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。 创建类使用 class 语句来创建一个新类，class 之后为类的名称并以冒号结尾: 123class ClassName: '类的帮助信息' #类文档字符串 class_suite #类体 类的帮助信息可以通过ClassName.doc查看。 class_suite 由类成员，方法，数据属性组成。 1234567891011121314151617181920class Employee: '所有员工的基类' empCount = 0 def __init__(self, name, salary): self.name = name self.salary = salary Employee.empCount += 1 def displayCount(self): print("Total Employee %d" % Employee.empCount) def displayEmployee(self): print("Name:",self.name,", Salary:",self.salary)chen = Employee('chen',100)jian = Employee('jian',200)Employee.displayCount(chen)Employee.displayEmployee(chen) 12Total Employee 2Name: chen , Salary: 100 empCount 变量是一个类变量，它的值将在这个类的所有实例之间共享。你可以在内部类或外部类使用 Employee.empCount 访问。 第一种方法init()方法是一种特殊的方法，被称为类的构造函数或初始化方法，当创建了这个类的实例时就会调用该方法 self 代表类的实例，self 在定义类的方法时是必须有的，虽然在调用时不必传入相应的参数。 self代表类的实例，而非类 类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self。 1234567class Test: def prt(self): print(self) print(self.__class__) t = Test()t.prt() 12&lt;__main__.Test object at 0x000002795B9841D0&gt;&lt;class '__main__.Test'&gt; 创建实例对象实例化类其他编程语言中一般用关键字 new，但是在 Python 中并没有这个关键字，类的实例化类似函数调用方式。 以下使用类的名称 Employee 来实例化，并通过 init 方法接收参数。 1234"创建 Employee 类的第一个对象"emp1 = Employee("Zara", 2000)"创建 Employee 类的第二个对象"emp2 = Employee("Manni", 5000) 访问属性您可以使用点号 . 来访问对象的属性。使用如下类的名称访问类变量: 123emp1.displayEmployee()emp2.displayEmployee()print("Total Employee %d" % Employee.empCount) 你也可以使用以下函数的方式来访问属性： getattr(obj, name[, default]) : 访问对象的属性。 hasattr(obj,name) : 检查是否存在一个属性。 setattr(obj,name,value) : 设置一个属性。如果属性不存在，会创建一个新属性。 delattr(obj, name) : 删除属性。 Python内置类属性 dict : 类的属性（包含一个字典，由类的数据属性组成） doc :类的文档字符串 name: 类名 module: 类定义所在的模块（类的全名是’main.className’，如果类位于一个导入模块mymod中，那么className.module 等于 mymod） bases : 类的所有父类构成元素（包含了一个由所有父类组成的元组） 1234567891011121314151617181920class Employee: '所有员工的基类' empCount = 0 def __init__(self, name, salary): self.name = name self.salary = salary Employee.empCount += 1 def displayCount(self): print("Total Employee %d" % Employee.empCount) def displayEmployee(self): print("Name : ", self.name, ", Salary: ", self.salary) print("Employee.__doc__:", Employee.__doc__)print("Employee.__name__:", Employee.__name__)print("Employee.__module__:", Employee.__module__)print("Employee.__bases__:", Employee.__bases__)print("Employee.__dict__:", Employee.__dict__) 12345Employee.__doc__: 所有员工的基类Employee.__name__: EmployeeEmployee.__module__: __main__Employee.__bases__: (&lt;class 'object'&gt;,)Employee.__dict__: &#123;'__module__': '__main__', '__doc__': '所有员工的基类', 'empCount': 0, '__init__': &lt;function Employee.__init__ at 0x000001AF85D0C2F0&gt;, 'displayCount': &lt;function Employee.displayCount at 0x000001AF867052F0&gt;, 'displayEmployee': &lt;function Employee.displayEmployee at 0x000001AF86705378&gt;, '__dict__': &lt;attribute '__dict__' of 'Employee' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'Employee' objects&gt;&#125; python对象销毁(垃圾回收)Python 使用了引用计数这一简单技术来跟踪和回收垃圾。 在 Python 内部记录着所有使用中的对象各有多少引用。 一个内部跟踪变量，称为一个引用计数器。 当对象被创建时， 就创建了一个引用计数， 当这个对象不再需要时， 也就是说， 这个对象的引用计数变为0 时， 它被垃圾回收。但是回收不是”立即”的， 由解释器在适当的时机，将垃圾对象占用的内存空间回收。 垃圾回收机制不仅针对引用计数为0的对象，同样也可以处理循环引用的情况。循环引用指的是，两个对象相互引用，但是没有其他变量引用他们。这种情况下，仅使用引用计数是不够的。Python 的垃圾收集器实际上是一个引用计数器和一个循环垃圾收集器。作为引用计数的补充， 垃圾收集器也会留心被分配的总量很大（及未通过引用计数销毁的那些）的对象。 在这种情况下， 解释器会暂停下来， 试图清理所有未引用的循环。 析构函数 del ，del在对象销毁的时候被调用，当对象不再被使用时，del方法运行： 123456789101112131415class Point: def __init__( self, x=0, y=0): self.x = x self.y = y def __del__(self): class_name = self.__class__.__name__ print(class_name, "销毁") pt1 = Point()pt2 = pt1pt3 = pt1print(id(pt1), id(pt2), id(pt3)) # 打印对象的iddel pt1del pt2del pt3 122009501876744 2009501876744 2009501876744Point 销毁 类的继承面向对象的编程带来的主要好处之一是代码的重用，实现这种重用的方法之一是通过继承机制。 通过继承创建的新类称为子类或派生类，被继承的类称为基类、父类或超类。 继承语法 12class 派生类名(基类名) ... 如果在继承元组中列了一个以上的类，那么它就被称作”多重继承” 。 语法： 派生类的声明，与他们的父类类似，继承的基类列表跟在类名之后，如下所示： 12class SubClassName (ParentClass1[, ParentClass2, ...]): ... 1234567891011121314151617181920212223242526class Parent: # 定义父类 parentAttr = 100 def __init__(self): print("调用父类构造函数") def parentMethod(self): print('调用父类方法') def setAttr(self, attr): Parent.parentAttr = attr def getAttr(self): print("父类属性 :", Parent.parentAttr) class Child(Parent): # 定义子类 def __init__(self): print("调用子类构造方法") def childMethod(self): print('调用子类方法') c = Child() # 实例化子类c.childMethod() # 调用子类的方法c.parentMethod() # 调用父类方法c.setAttr(200) # 再次调用父类的方法 - 设置属性值c.getAttr() # 再次调用父类的方法 - 获取属性值 1234调用子类构造方法调用子类方法调用父类方法父类属性 : 200 你可以使用issubclass()或者isinstance()方法来检测。 issubclass() - 布尔函数判断一个类是另一个类的子类或者子孙类，语法：issubclass(sub,sup) isinstance(obj, Class) 布尔函数如果obj是Class类的实例对象或者是一个Class子类的实例对象则返回true。 方法重写如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法： 12345678910class Parent: # 定义父类 def myMethod(self): print('调用父类方法') class Child(Parent): # 定义子类 def myMethod(self): print('调用子类方法') c = Child() # 子类实例c.myMethod() # 子类调用重写方法 基础重载方法下表列出了一些通用的功能，你可以在自己的类重写： 方法, 描述 &amp; 简单的调用 序号 init ( self [,args…] ) 构造函数简单的调用方法: obj = className(args) 1 del( self ) 析构方法, 删除一个对象简单的调用方法 : del obj 2 repr( self ) 转化为供解释器读取的形式简单的调用方法 : repr(obj) 3 str( self )用于将值转化为适于人阅读的形式简单的调用方法 : str(obj) 4 运算符重载Python同样支持运算符重载，实例如下： 1234567891011121314class Vector: def __init__(self, a, b): self.a = a self.b = b def __str__(self): return('Vector (%d, %d)' % (self.a, self.b)) def __add__(self,other): return(Vector(self.a + other.a, self.b + other.b)) v1 = Vector(2,10)v2 = Vector(5,-2)print(v1 + v2) 1Vector (7, 8) 类属性与方法类的私有属性 __private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs。 类的方法在类的内部，使用 def 关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数 self,且为第一个参数 类的私有方法__private_method：两个下划线开头，声明该方法为私有方法，不能在类的外部调用。在类的内部调用 self.__private_methods 1234567891011121314class JustCounter: __secretCount = 0 # 私有变量 publicCount = 0 # 公开变量 def count(self): self.__secretCount += 1 self.publicCount += 1 print(self.__secretCount) counter = JustCounter()counter.count()counter.count()print(counter.publicCount)print(counter.__secretCount) # 报错，实例不能访问私有变量 1234567122Traceback (most recent call last): File "F:\python37_chen\1.py", line 14, in &lt;module&gt; print(counter.__secretCount) # 报错，实例不能访问私有变量AttributeError: 'JustCounter' object has no attribute '__secretCount' Python不允许实例化的类访问私有数据，但你可以使用 object._className__attrName（ 对象名._类名__私有属性名 ）访问属性，参考以下实例： 1print(counter._JustCounter__secretCount) 12 单下划线、双下划线、头尾双下划线说明： foo: 定义的是特殊方法，一般是系统定义名字 ，类似 init() 之类的。 _foo: 以单下划线开头的表示的是 protected 类型的变量，即保护类型只能允许其本身与子类进行访问，不能用于 from module import * __foo: 双下划线的表示的是私有类型(private)的变量, 只能是允许这个类本身进行访问了。 —欲知后事如何，且听下回分解]]></content>
      <categories>
        <category>Python 教程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[19.Python的异常处理]]></title>
    <url>%2Fpython%2F19.Python%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html</url>
    <content type="text"><![CDATA[书接上文Python 异常处理python提供了两个非常重要的功能来处理python程序在运行中出现的异常和错误。你可以使用该功能来调试python程序。 异常处理 断言(Assertions) python标准异常 异常名称 描述 BaseException 所有异常的基类 SystemExit 解释器请求退出 KeyboardInterrupt 用户中断执行(通常是输入^C) Exception 常规错误的基类 StopIteration 迭代器没有更多的值 GeneratorExit 生成器(generator)发生异常来通知退出 StandardError 所有的内建标准异常的基类 ArithmeticError 所有数值计算错误的基类 FloatingPointError 浮点计算错误 OverflowError 数值运算超出最大限制 ZeroDivisionError 除(或取模)零 (所有数据类型) AssertionError 断言语句失败 AttributeError 对象没有这个属性 EOFError 没有内建输入,到达EOF 标记 EnvironmentError 操作系统错误的基类 IOError 输入/输出操作失败 OSError 操作系统错误 WindowsError 系统调用失败 ImportError 导入模块/对象失败 LookupError 无效数据查询的基类 IndexError 序列中没有此索引(index) KeyError 映射中没有这个键 MemoryError 内存溢出错误(对于Python 解释器不是致命的) NameError 未声明/初始化对象 (没有属性) UnboundLocalError 访问未初始化的本地变量 ReferenceError 弱引用(Weak reference)试图访问已经垃圾回收了的对象 RuntimeError 一般的运行时错误 NotImplementedError 尚未实现的方法 SyntaxError Python 语法错误 IndentationError 缩进错误 TabError Tab 和空格混用 SystemError 一般的解释器系统错误 TypeError 对类型无效的操作 ValueError 传入无效的参数 UnicodeError Unicode 相关的错误 UnicodeDecodeError Unicode 解码时的错误 UnicodeEncodeError Unicode 编码时错误 UnicodeTranslateError Unicode 转换时错误 Warning 警告的基类 DeprecationWarning 关于被弃用的特征的警告 FutureWarning 关于构造将来语义会有改变的警告 OverflowWarning 旧的关于自动提升为长整型(long)的警告 PendingDeprecationWarning 关于特性将会被废弃的警告 RuntimeWarning 可疑的运行时行为(runtime behavior)的警告 SyntaxWarning 可疑的语法的警告 UserWarning 用户代码生成的警告 什么是异常？异常即是一个事件，该事件会在程序执行过程中发生，影响了程序的正常执行。 一般情况下，在Python无法正常处理程序时就会发生一个异常。 异常是Python对象，表示一个错误。 当Python脚本发生异常时我们需要捕获处理它，否则程序会终止执行。 异常处理捕捉异常可以使用try/except语句。 try/except语句用来检测try语句块中的错误，从而让except语句捕获异常信息并处理。 如果你不想在异常发生时结束你的程序，只需在try里捕获它。 语法： 以下为简单的try….except…else的语法： 12345678try:&lt;语句&gt; #运行别的代码except &lt;名字&gt;：&lt;语句&gt; #如果在try部份引发了'name'异常except &lt;名字&gt;，&lt;数据&gt;:&lt;语句&gt; #如果引发了'name'异常，获得附加的数据else:&lt;语句&gt; #如果没有异常发生 try的工作原理是，当开始一个try语句后，python就在当前程序的上下文中作标记，这样当异常出现时就可以回到这里，try子句先执行，接下来会发生什么依赖于执行时是否出现异常。 如果当try后的语句执行时发生异常，python就跳回到try并执行第一个匹配该异常的except子句，异常处理完毕，控制流就通过整个try语句（除非在处理异常时又引发新的异常）。 如果在try后的语句里发生了异常，却没有匹配的except子句，异常将被递交到上层的try，或者到程序的最上层（这样将结束程序，并打印默认的出错信息）。 如果在try子句执行时没有发生异常，python将执行else语句后的语句（如果有else的话），然后控制流通过整个try语句。 使用except而不带任何异常类型12345678try: 正常的操作 ......................except: 发生异常，执行这块代码 ......................else: 如果没有异常执行这块代码 使用except而带多种异常类型你也可以使用相同的except语句来处理多个异常信息 12345678try: 正常的操作 ......................except(Exception1[, Exception2[,...ExceptionN]]]): 发生以上多个异常中的一个，执行这块代码 ......................else: 如果没有异常执行这块代码 try-finally 语句try-finally 语句无论是否发生异常都将执行最后的代码。 12345try:&lt;语句&gt;finally:&lt;语句&gt; #退出try时总会执行raise 异常的参数一个异常可以带上参数，可作为输出的异常信息参数。 你可以通过except语句来捕获异常的参数，如下所示： 12345try: 正常的操作 ......................except ExceptionType, Argument: 你可以在这输出 Argument 的值... 变量接收的异常值通常包含在异常的语句中。在元组的表单中变量可以接收一个或者多个值。 元组通常包含错误字符串，错误数字，错误位置。 触发异常我们可以使用raise语句自己触发异常 raise语法格式如下： 1raise [Exception [, args [, traceback]]] 语句中 Exception 是异常的类型（例如，NameError）参数标准异常中任一种，args 是自已提供的异常参数。 最后一个参数是可选的（在实践中很少使用），如果存在，是跟踪异常对象。 用户自定义异常通过创建一个新的异常类，程序可以命名它们自己的异常。异常应该是典型的继承自Exception类，通过直接或间接的方式。 以下为与RuntimeError相关的实例,实例中创建了一个类，基类为RuntimeError，用于在异常触发时输出更多的信息。 在try语句块中，用户自定义的异常后执行except块语句，变量 e 是用于创建Networkerror类的实例。 其实我很少用这个异常处理，原因在于时候未到，还没有达到贡献自己代码的高度，将来进阶的时候再研究这个，初学者可以跳过这一部分，与其把时间花在处理异常，不如多学一点，思考的更全面一点。 —欲知后事如何，且听下回分解]]></content>
      <categories>
        <category>Python 教程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[18.Python的文件]]></title>
    <url>%2Fpython%2F18.Python%E7%9A%84%E6%96%87%E4%BB%B6.html</url>
    <content type="text"><![CDATA[书接上文文件 File 文件是用于存储数据的基本单位 文件通常用来长期存储数据 文件中数据是以字节为单位进行顺序存储的文件的操作流程 打开文件 读/写文件 关闭文件 12注: 任何的操作系统,一个应用程序同时打开文件的数量 有最大数限制文件的打开函数 open(filename, mode=’rt’) 用于打开一个文件,返回 此用来操作此文件的文件流对象,如果打开失败, 则会触发OSError错误通知 文件流对象的关闭方法 F.close() 关闭文件.释放系统资源 1.创建写入文件1234f = open('C:/Users/CC/Desktop/a.txt','a')for i in range(10): f.write(str(i)+'\n')f.close() 123456789100123456789 2.读文件123456f = open('C:/Users/CC/Desktop/a.txt','r')s = f.read()print(s)f.close() 123456789100123456789 这是最简单的两个示例，具体的方法语法： 12&gt; open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)&gt; 参数说明: file: 必需，文件路径（相对或者绝对路径）。 mode: 可选，文件打开模式 buffering: 设置缓冲 encoding: 一般使用utf8 errors: 报错级别 newline: 区分换行符 closefd: 传入的file参数类型 opener mode 参数有： 模式 描述 t 文本模式 (默认)。 x 写模式，新建一个文件，如果该文件已存在则会报错。 b 二进制模式。 + 打开一个文件进行更新(可读可写)。 U 通用换行模式（不推荐）。 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。 w 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 w+ 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 file 对象file 对象使用 open 函数来创建，下表列出了 file 对象常用的函数： 序号 方法及描述 1 file.close()关闭文件。关闭后文件不能再进行读写操作。 2 file.flush()刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。 3 file.fileno()返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。 4 file.isatty()如果文件连接到一个终端设备返回 True，否则返回 False。 5 file.next()返回文件下一行。 6 [file.read(size])从文件读取指定的字节数，如果未给定或为负则读取所有。 7 file.readline([size])读取整行，包括 “\n” 字符。 8 file.readlines([sizeint])读取所有行并返回列表，若给定sizeint&gt;0，则是设置一次读多少字节，这是为了减轻读取压力。 9 file.seek(offset[, whence])设置文件当前位置 10 file.tell()返回文件当前位置。 11 file.truncate([size])截取文件，截取的字节通过size指定，默认为当前文件位置。 12 file.write(str)将字符串写入文件，返回的是写入的字符长度。 13 file.writelines(sequence)向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。 十个汉字占多少个字节?汉字编码(只有两种) 国标系列: GB18030(二字节或四字节编码, 27533个字) GBK(二字节编码,20013个字) GB2313(二字节编码,约7千多个字) (Windows常用) 国际标准: UNICODE(UNCODE16/UNICODE32) &lt;-&gt; UTF-8 (Linux/Mac OS X/ IOS/ Android 常用) UTF-8中: 英文ASCII (0x0 - 0x7F) 一字节 (0x80 - 0x3FF) 二字节 (0x400 - 0xFFFF) 三字节(中文在此区) python 编码字符串: ‘gb2312’ ‘gbk’ ‘gb18030’ ‘utf-8’ ‘ascii’ … 如: 1234s = "你好" print(s.encode('gbk')) print(s.encode('utf-8')) print(s.encode('ascii'))#出错,"你好"不在ascii内 编码注释: 在源文件中,第一行或第二行写入的如下内容是编码注释 1234567s = "百度"print(s.encode('gbk'))print(s.encode('utf-8'))b'\xb0\xd9\xb6\xc8'b'\xe7\x99\xbe\xe5\xba\xa6' 作业：1.写程序实现复制文件的功能 要求: 1. 要考虑超大文件问题 2. 要能复制二进制文件(如:图片等) 3. 要考虑关闭文件 12345678910111213141516171819202122232425262728293031323334# 1. 写程序实现复制文件的功能# 要求:# 1. 要考虑超大文件问题# 2. 要能复制二进制文件(如:图片等)# 3. 要考虑关闭文件def copyfile(src_file, dst_file): '''src_file 源文件名 dst_file 目标文件名''' try: fr = open(src_file, 'rb') # 读文件 try: try: fw = open(dst_file, 'wb') # 写文件 try: while True: # 每次搬4096个字节 data = fr.read(4096) if not data: # 已到达文件尾 break fw.write(data) print("复制文件有成功") finally: fw.close() except OSError: print("复制失败") finally: fr.close() except OSError: print("复制失败")src = input("请输入源文件: ")dst = input("请输入目标文件: ")copyfile(src, dst) —欲知后事如何，且听下回分解]]></content>
      <categories>
        <category>Python 教程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[17.Python的模块]]></title>
    <url>%2Fpython%2F17.Python%E7%9A%84%E6%A8%A1%E5%9D%97.html</url>
    <content type="text"><![CDATA[书接上文Python 模块Python 模块(Module)，是一个 Python 文件，以 .py 结尾，包含了 Python 对象定义和Python语句。模块让你能够有逻辑地组织你的 Python 代码段。把相关的代码分配到一个模块里能让你的代码更好用，更易懂。模块能定义函数，类和变量，模块里也能包含可执行的代码。 import 语句我们按照上一章的函数方式可以定义自己的模块，例如：my_print.py 12def chen_print(s): return ('Hello:' + s) 在当前文件夹下新建model_test.py 123import my_print as mpprint(mp.chen_print('haha')) //Hello:haha 如果在当前目录下，直接 import 导入就可以了，此外还可以用as给他重命名，你要导入这个文件中哪些模块，直接用 . 就可以了 from…import 语句Python 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中 12345from my_print import chen_printprint(chen_print('haha')) //Hello:haha from…import * 语句 //使用*将所有模块导入进来，你也可以定义哪些模块能被这样的语法导入，后面再聊 搜索路径当你导入一个模块，Python 解析器对模块位置的搜索顺序是： 1、当前目录 2、如果不在当前目录，Python 则搜索在 shell 变量 PYTHONPATH 下的每个目录。 3、如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/。 模块搜索路径存储在 system 模块的 sys.path 变量中。变量里包含当前目录，PYTHONPATH和由安装过程决定的默认目录。 搜索路径怎么理解呢？ 你可以认为程序是怎么找到你写的模块，想一想，我们刚开始是不是说在当前目录下创建测试文件，其实就是这个原因，你如果不告诉程序去哪里找，它默认先找当前目录，然后看你指定的目录，也就是环境变量，也就是shell变量下的PYTHONPATH的所有目录，如果都找不到，那就找程序默认的路径。 我们可以借 sys这个模块来查看路径，如果你自己写的包或者安装的第三方模块没有在这些路径下，那么可能没法使用模块哦 123&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.path['', 'C:\\Program Files\\Python37\\Lib\\idlelib', 'C:\\Program Files\\Python37\\python37.zip', 'C:\\Program Files\\Python37\\DLLs', 'C:\\Program Files\\Python37\\lib', 'C:\\Program Files\\Python37', 'C:\\Users\\CC\\AppData\\Roaming\\Python\\Python37\\site-packages', 'C:\\Program Files\\Python37\\lib\\site-packages'] 假如说我们知道路径不在这里面，怎么添加使用呢？ windows: 此电脑 —&gt; 属性 —&gt; 高级系统设置 —&gt; 环境变量 —&gt; Path 进行添加即可，通常都是你安装地址的bin下的目录 Linux：123vim ~/.bashrcexport PYTHONPATH=$PYTHONPATH:/YOU_MODULE_DIRECTORYsource ~/.bashrc 如果说你想大量管理这些路径呢？ pth文件这种方式很简单便于管理，在需要大量添加外部路径的时候非常推荐，而且是永久生效。启动Python程序时候，解释器就会遍历目录，遇到pth就会读取这个文件中的内容并添加到sys.path中。这里以系统自带的Python2.7为例说明 1234cd /usr/lib/python2.7/site-packagescat Allinone.path//内容就是路径 不可忽视模块的路径学习，这是初学者最大问题，模块都用不了，搬砖都没法搬 dir()函数dir() 函数一个排好序的字符串列表，内容是一个模块里定义过的名字。 返回的列表容纳了在一个模块里定义的所有模块，变量和函数 开始我们学习math的时候使用过这个函数，不知道还有没有印象，假如你恍惚记得my_print这个文件名，里面具体的模块函数忘记了怎么办？ 123import my_printprint(dir(my_print)) 1['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'chen_print'] 看见这个列表了吗？里面有个 chen_print正好是我们要找的函数。那么其他这么多玩意儿是什么？可以不用管它，当它是系统自带吧。我们就简单操作一下，看看和我们的模块关系，也是为了后面理解面对对象铺垫一下。 12345''' 这是我自己的打印函数'''def chen_print(s): return ('Hello:' + s) 1234import my_printprint(my_print.__name__)print(my_print.__doc__) 123my_print 这是我自己的打印函数 大概了解了一点吧，原来系统默认了一些模块自身的东西，比如帮助文档和模块的名字 命名空间和作用域变量是拥有匹配对象的名字（标识符）。命名空间是一个包含了变量名称们（键）和它们各自相应的对象们（值）的字典。 一个 Python 表达式可以访问局部命名空间和全局命名空间里的变量。如果一个局部变量和一个全局变量重名，则局部变量会覆盖全局变量。 每个函数都有自己的命名空间。类的方法的作用域规则和通常函数的一样。 Python 会智能地猜测一个变量是局部的还是全局的，它假设任何在函数内赋值的变量都是局部的。 因此，如果要给函数内的全局变量赋值，必须使用 global 语句。 global VarName 的表达式会告诉 Python， VarName 是一个全局变量，这样 Python 就不会在局部命名空间里寻找这个变量了。 例如，我们在全局命名空间里定义一个变量 Money。我们再在函数内给变量 Money 赋值，然后 Python 会假定 Money 是一个局部变量。然而，我们并没有在访问前声明一个局部变量 Money，结果就是会出现一个 UnboundLocalError 的错误。取消 global 语句前的注释符就能解决这个问题。 123456789Money = 100def AddMoney(): # global Money Money = Money + 1 print(Money)AddMoney()print(Money) 因为函数也不知道这个Money哪来的，又没人给它传参，所以只好报错 1234567100Traceback (most recent call last): File "C:\Users\CC\Desktop\print\model_test.py", line 8, in &lt;module&gt; AddMoney() File "C:\Users\CC\Desktop\print\model_test.py", line 5, in AddMoney Money = Money + 1UnboundLocalError: local variable 'Money' referenced before assignment 我们再试试加上声明它是全局变量 12345678Money = 100def AddMoney(): global Money Money = Money + 1 print(Money)AddMoney()print(Money) 12100101 还记得我们讲过的可变不可变吗？我们用下面的几个例子帮助对比理解 12345678Money = 100def AddMoney(money): Money = Money + 1 print(Money) print(Money)AddMoney(Money)print(Money) 1234567100Traceback (most recent call last): File "C:\Users\CC\Desktop\print\model_test.py", line 7, in &lt;module&gt; AddMoney(Money) File "C:\Users\CC\Desktop\print\model_test.py", line 3, in AddMoney Money = Money + 1UnboundLocalError: local variable 'Money' referenced before assignment 12345678Money = 100def AddMoney(money): money = money + 1 print(Money) print(Money)AddMoney(Money)print(Money) 123100100100 12345678910Money = 100def AddMoney(money): money = Money + 2 print(Money) print(money) print(Money)AddMoney(Money)print(Money) 1234100100102100 123456789Money = 100def AddMoney(money): global Money money += 1 print(Money)AddMoney(Money)print(money) // 外面没法访问里面的变量，所以这里报错 请仔细体会各种情况下的输出，这些示例能够帮助你理解函数，不可忽视这些细节，因为今后的编程发生一些不知名的错误，往往都是命名空间不对，程序庞大的话很难排错，最好的办法就是熟悉函数，然后不要用 global ，神奇吧，为了不用它而学它。 globals() 和 locals() 函数根据调用地方的不同，globals() 和 locals() 函数可被用来返回全局和局部命名空间里的名字。 如果在函数内部调用 locals()，返回的是所有能在该函数里访问的命名。 如果在函数内部调用 globals()，返回的是所有在该函数里能访问的全局名字。 两个函数的返回类型都是字典。所以名字们能用 keys() 函数摘取。代码栗子： 123456789a = 1b = 2def c(): d = 4print(globals())print('*'*20)print(locals()) 123&#123;'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__spec__': None, '__annotations__': &#123;&#125;, '__builtins__': &lt;module 'builtins' (built-in)&gt;, '__file__': 'C:\\Users\\CC\\Desktop\\print\\my_print.py', 'argv': ['C:\\Users\\CC\\Desktop\\print\\my_print.py'], 'a': 1, 'b': 2, 'c': &lt;function c at 0x00000295CA3ED5E8&gt;&#125;********************&#123;'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__spec__': None, '__annotations__': &#123;&#125;, '__builtins__': &lt;module 'builtins' (built-in)&gt;, '__file__': 'C:\\Users\\CC\\Desktop\\print\\my_print.py', 'argv': ['C:\\Users\\CC\\Desktop\\print\\my_print.py'], 'a': 1, 'b': 2, 'c': &lt;function c at 0x00000295CA3ED5E8&gt;&#125; 所以，你还可以使用这两个函数进行模块函数的调用和查看哦 reload() 函数当一个模块被导入到一个脚本，模块顶层部分的代码只会被执行一次。 因此，如果你想重新执行模块里顶层部分的代码，可以用 reload() 函数。该函数会重新导入之前导入过的模块。注意不要用字符串，直接输入模块名字就可以了 Python中的包包是一个分层次的文件目录结构，它定义了一个由模块及子包，和子包下的子包等组成的 Python 的应用环境。 简单来说，包就是文件夹，但该文件夹下必须存在 init.py 文件, 该文件的内容可以为空。init.py 用于标识当前文件夹是一个包。 其实见的包多了自然能够理解，随便下载包，注意都是有init这个文件的，我们举例说明： 12345test.pypackage|-- __init__.py|-- 1.py|-- 2.py 123456789101112131415161718#1.pydef one(): print('one')#2.pydef two(): print('two')#test.pyfrom package.1 import onefrom package.2 import twoone()two()#__init__.pyif __name__ == "__main__": print('作为主程序运行')else: print('模块初始化') 我们运行一下test看看效果： 123模块初始化onetwo 好像它还运行了init这是怎么回事呢，程序它找包，其实给它这样一个限制之后，它就能够很方便管理这个文件夹下的所有模块了，相当于一个配置文件。我们再单独运行它看看： 1作为主程序运行 还记得前面看全局变量吗？它有这样的一个属性，来判断是不是主程序。 这个玩意儿又有什么用？ 其实你写函数的时候，写模块的时候，自然要测试一下程序能否正常运行，但是测试过后吧又不想删测试代码，毕竟能够证明你这代码是正确的，而且很方便移植的时候进行调试更改，所以很多程序的单元代码测试都可以直接这样写，确保每个功能正确，拼装起来自然容易。 题外话：其实我们使用import 和 from 导入就是导包，凡是带点的左边都必须是包才可以，随着模块的增多，增加模块的管理方便后期的维护是很重要的。 —欲知后事如何，且听下回分解]]></content>
      <categories>
        <category>Python 教程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[16.Python的函数]]></title>
    <url>%2Fpython%2F16.Python%E7%9A%84%E5%87%BD%E6%95%B0.html</url>
    <content type="text"><![CDATA[书接上文Python 函数函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。函数能提高应用的模块性，和代码的重复利用率。你已经知道Python提供了许多内建函数，比如print()。但你也可以自己创建函数，这被叫做用户自定义函数。注意：这一节属于重难点，务必吃透。这是进阶为高级程序员的必经之路，想让别人用你的代码？不想一段代码反复编写？那就一定要会写函数。之前我们也提到过你使用别人的函数，只关心功能，输入输出就可以了，那么你也要这样设计你的函数。 函数的思想就是化繁为简，每个函数只负责一个功能，通过功能的组合才能形成各种复杂的程序结构。编程语言已经为你设计了很多高效方便的基础函数，其实加法功能就是一个函数，你可以在任何需要加法的地方使用它。 定义一个函数你可以定义一个由自己想要功能的函数，以下是简单的规则： 函数代码块以 def 关键词开头，后接函数标识符名称和圆括号()。 任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。 函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。 函数内容以冒号起始，并且缩进。 return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。 语法1234def functionname( parameters ): "函数_文档字符串" function_suite return [expression] 文档字符串说明你函数的主要作用，输入输出的解释，通常可以用三引号表述 我们写一个自己的打印函数： 1234567891011121314def chen_print(s): ''' 我自己的打印函数，在系统打印的字符串前面加我的名字 输入：一个输入字符串 输出：我的字符串 ''' print('chenjian:' + s) return Nones = 'hello'a = chen_print(s)chenjian:hello 函数调用定义一个函数只给了函数一个名称，指定了函数里包含的参数，和代码块结构。仔细观察我们上面的代码会了解到我们是怎么调用自己的函数呢？ 你要注意我们定义了函数 def 程序运行到这里其实并没有进入函数内部，而是直接走过 s = ‘hello’ 下一句就关键了，它看到我们要将 chen_print(s) 绑定到 a 变量身上，可是系统没有这个函数啊，咦，它发现我们自己定义了这个函数，所以它抱着 s 去找我们的自定义函数，自定义函数一看 s 实打实的真s ，再看看自己手上的模型假 s ，表示愿意接受。就进入函数内部运行，完了之后 return 返回一个东西给系统好给 a 交差啊，但是这里的函数就是我什么都不给，默认也是这样。这整个过程就是函数的调用和参数传递 参数传递我们再聊五毛钱的参数传递 12345678910111213141516171819202122232425262728293031323334353637def chen_print(s): ''' 我自己的打印函数，在系统打印的字符串前面加我的名字 输入：一个输入字符串 输出：我的字符串 ''' print('chenjian:' + s) return Nones = 'hello'ss = '[1,2,3]'sss = 10a = chen_print(s)b = chen_print(ss)c = chen_print(sss)chenjian:hellochenjian:[1,2,3]Traceback (most recent call last): File "&lt;ipython-input-8-82b1c8879221&gt;", line 1, in &lt;module&gt; runfile('C:/Users/CC/Desktop/for.py', wdir='C:/Users/CC/Desktop') File "H:\Anaconda\lib\site-packages\spyder_kernels\customize\spydercustomize.py", line 786, in runfile execfile(filename, namespace) File "H:\Anaconda\lib\site-packages\spyder_kernels\customize\spydercustomize.py", line 110, in execfile exec(compile(f.read(), filename, 'exec'), namespace) File "C:/Users/CC/Desktop/for.py", line 16, in &lt;module&gt; c = chen_print(sss) File "C:/Users/CC/Desktop/for.py", line 7, in chen_print print('chenjian:' + s)TypeError: can only concatenate str (not "int") to str 看报错信息就知道是类型出了问题，这也正好暴露了python的一个问题，那就是动态类型，我们可能根本不知道到底输入什么类型，输出什么类型。解决办法也不是没有，只不过都太繁琐了违背了简约的思想，所以，花时间完善你的文档字符串吧，至少让你自己能够看懂你的函数想干嘛。 123456789101112def chen_print(s): ''' 我自己的打印函数，在系统打印的字符串前面加我的名字 输入：一个输入字符串 输出：我的字符串 ''' print('chenjian:' + s) return Nones = 'hello'a = chen_print(s)print(a) 12chenjian:helloNone 在 python 中，类型属于对象，变量是没有类型的： 怎么理解？ 12a = [1,2,3]a = 'sss' 这里看其实对象[1,2,3] 是列表类型，‘sss’就是字符串类型，a只是一个便利贴，开始它贴在列表上，你想访问列表，找便利贴就可以了，后来它又贴在字符串上，之前的列表怎么办？如果没有其他的标签，系统会认为这货是垃圾，干脆回收算了。 可更改(mutable)与不可更改(immutable)对象在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。 不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。 可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。 python 函数的参数传递： 不可变类型：类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。 可变类型：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响 python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。 上面的话如果听起来比较懵逼，尤其C++只是听说过。那就看看下面的代码，我们详细看看他们之间的区别 python 传不可变对象实例123456789def changeint(a): print('我进来了哦，看看我是谁:',a) a = 10 print('我改变了哦，看看我是谁:',a) b = 1print('我没使用函数前:',b)changeint(b)print('我使用了函数后:',b) 1234我没使用函数前: 1我进来了哦，看看我是谁: 1我改变了哦，看看我是谁: 10我使用了函数后: 1 先甭管它可变不可变，函数的调用和传参这个例子是不是表现的明明白白，安排！再来看，刚进去的时候是把a这个标签贴在了1上面，然后创建了 10 这个对象 ，把a这个标签又贴到了10上面。 python 传可变对象实例123456789def changelist(a): print('我进来了哦，看看我是谁:',a) a[0] = 'chen' print('我改变了哦，看看我是谁:',a) b = [1,2,3]print('我没使用函数前:',b)changelist(b)print('我使用了函数后:',b) 1234我没使用函数前: [1, 2, 3]我进来了哦，看看我是谁: [1, 2, 3]我改变了哦，看看我是谁: ['chen', 2, 3]我使用了函数后: ['chen', 2, 3] 看到区别了吗，b本身也发生的变化，初学很难理解的话，你就当作不可变的对象只是给你我的值，你的权限只能贴贴标签，反正我借给你的东西，别人再问我要你要还我当初的模样。而可变类型就不一样了，你借出去的就是篮球了，用一次脏一次，每次的图画印记都能看到，说不定还你的看样子成了足球也说不定，总之，你要是正好想要一个涂鸦篮球，或者签名篮球，倒也正合你意。 我们再看个例子终结这个话题。 123456789def changetuple(a): print('我进来了哦，看看我是谁:',a) a[0][0] = 'chen' print('我改变了哦，看看我是谁:',a) b = ([1],[2])print('我没使用函数前:',b)changetuple(b)print('我使用了函数后:',b) 1234我没使用函数前: ([1], [2])我进来了哦，看看我是谁: ([1], [2])我改变了哦，看看我是谁: (['chen'], [2])我使用了函数后: (['chen'], [2]) 元组不是不可变吗？仔细体会，注意里面的元素是列表属于可变类型。 参数以下是调用函数时可使用的正式参数类型： 必备参数 关键字参数 默认参数 不定长参数 参数是至关重要的，它是函数的输入口，口都没找到，怎么进行下去呢？ 而且，我们前面谈过了参数类型的问题，还有就是参数数目一定要能对应得上，否则就不是自己人，密码位数都输错，进门的资格都没有。 关键字参数关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。 就是说门上直接写明白只有谁能进门，而默认的方式是排队进对应的门，第一个进第一个门，关键字的话，基本就是各找各家，举个栗子： 1234def keyword(name,password): return 'please:&#123;&#125;.&#123;&#125;'.format(name,password)a = keyword(password='123'，name='chen') 12aOut[16]: 'please:chen.123' 默认参数调用函数时，默认参数的值如果没有传入，则被认为是默认值 举个栗子： 1234def keyword(name='chen',password='123'): return 'please:&#123;&#125;.&#123;&#125;'.format(name,password)a = keyword() 12aOut[18]: 'please:chen.123' 这种写法可以极大避免程序报错情况的发生，设置很多习惯上的默认值可以简化用户繁重的输入工作 不定长参数你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述2种参数不同，声明时不会命名。基本语法如下： 1234def functionname([formal_args,] *var_args_tuple ): "函数_文档字符串" function_suite return [expression] 加了星号（*）的变量名会存放所有未命名的变量参数。星号的意思表达的就是通配符的意思，这样就可以对参数组进行解包，获取所有的参数了 举个栗子： 12345678910111213141516171819&gt;&gt;&gt; def args(arg1,*args): print(arg1) for i in args: print(i) &gt;&gt;&gt; args('1')1&gt;&gt;&gt; args('1','2','3')123&gt;&gt;&gt; args(('1','2'),'3')('1', '2')3&gt;&gt;&gt; args(1,2,3)123 首先匹配第一个参数，然后把剩下的参数都打包成元组给args 123456789def f1(a, b, c=0, *args, **kw): print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)a = 1b = 2c = 3args = ('a', 'b')kw = &#123;'x': 99&#125;f1(a,b,c,args,kw) 1a = 1 b = 2 c = 3 args = (('a', 'b'), &#123;'x': 99&#125;) kw = &#123;&#125; 在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。 对于任意函数，都可以通过类似func(*args, **kw)的形式调用它 递归函数在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。递归是一种思想，它让一些循环处理的复杂问题变得简单。看下面的例子： 12345678# 实现一个从1加到100的递归函数def sum_n(n): if n == 1: return n return sum_n(n-1) + na = sum_n(100)print(a) 15050 大家都听说过高斯大神的故事吧，相信大家也熟知了头尾相加的高效算法，当然你也可以使用比较传统的等差数列求和公式： 12345def sum_n_fuc(n): return ((n+1)*n)/2a = sum_n_fuc(100)print(a) 我们还是先看一看第一个递归函数，其实求1加到100的和，不妨拆解成前99个数的和加100，所以我们调用sum_n(n-1),那么这个函数调用自身的时候发现不满足n==1的条件，那就自身再减1加上当前的n值，这样一直循环下去，终于到了满足条件然后返回结果。这样就可以将问题简化成前99，前98，直到前1个数和，当然了，递归的思想虽然让人简单，机器可不好做了，首先，它要记住每一次的调用吗，就好像什么情况： 123456789101112程序：sum_n(100)你等于多少啊？sum_n(100):我不知道，我给你100，你带着去找sum_n(99)问问,然后加起来就可以了程序：sum_n(99)你等于多少啊？我兜里有100sum_n(99):我不知道，我给你99，你带着去找sum_n(98)问问,然后加起来就可以了程序：sum_n(98)你等于多少啊？我兜里有100,99sum_n(98):我不知道，我给你98，你带着去找sum_n(97)问问,然后加起来就可以了...sum_n(1):我等于1啊程序：卧槽，我兜里有100，99，...1，我加起来看看，咦5050 所以说，递归通常是很占用内存空间的，很多程序也有递归层数限制。那么有没有什么办法来优化递归呢？我们顺序递归就可以了，这样我们加一个存一个，就不会存在递归层数太多内存爆掉了。 我们总结一下，函数式的编程比较简单，无非就是在我们想要实现的某代码块前加def就可以了，我们告诉它，要给它什么东西，通过函数的功能进行加工，最终return出我们想要的东西进行接收。那么有哪些必须要注意的呢？输入参数我们要注意，必选参数、默认参数、可变参数、命名关键字参数和关键字参数位置不能变，必选参数用的比较多，就是按位置排队往里放嘛，默认参数是门上有名字，指定的才能进，还要注意默认参数必须指向不变对象可变就是可以传几个参数，函数对它进行解包操作，关键字参数就是调用的时候我指定给哪个参数进行传，命名关键字参数就是可以向函数传递很多带名字的参数，函数内部可以对其进行解包。初学者，看上面的内容可能比较难以理解，虽然上面的示例已经讲过一遍，不妨我们再看一点示例： 我们想要自定义一个pow函数实现和内置函数一样的功能，我们看看pow是怎么使用的： 12345678&gt;&gt;&gt; help(pow)Help on built-in function pow in module builtins:pow(x, y, z=None, /) Equivalent to x**y (with two arguments) or x**y % z (with three arguments) Some types, such as ints, are able to use a more efficient algorithm when invoked using the three argument form. 我们利用位置参数，也就是必选参数来实现第一个功能： 12345def my_pow(a,b): return a**bc = my_pow(2,5)print(c) 很多文章中将a,b叫做形式参数，就是装样子，占位置的，2，5是实际参数，实实在在的参数，有实际意义的。它们必须位置对应才能没有歧义嘛。这就是位置参数。那么我们同样很容易实现第二个功能求对z的余数 12345def my_pow(a,b,z): return a**b%zc = my_pow(2,5,3)print(c) 可是内置函数中是不需要传入z这个参数的，不传入就是求幂，传入就是求幂余。我们不得不使用默认参数的选项了。 位置参数，默认参数实现两个功能 1234567def my_pow(a,b,z=None): if z == None: return a**b return a**b%zc = my_pow(2,5)print(c) 这样你就完全实现了pow的功能呢，那么要是有更刁难的用户说，他们不习惯 a的b次方这种读法，更喜欢 b次方的a呢？如果调换顺序，那就违背了位置参数的约束，不如这样吧，你干脆告诉我 a 等于多少，b等于多少吧。 那么，我们用关键字参数实现了这个需求 1234567def my_pow(a,b,z=None): if z == None: return a**b return a**b%zc = my_pow(b=5,a=2) //这里就是关键字，直接告诉它，a,b的值，那就不用在乎位置了print(c) 我们还想实现一个不限制用户输入多少个参数，我们都一直求和下去，这里就用到了不定长参数 12345678910def my_pow(*var): print(var) _sum = 0 _len = len(var) for i in var: _sum += i return _sumc = my_pow(1,2,3)print(c) 12(1, 2, 3)6 注意这里是元组，我们得到了这个未知个数的参数，通过解包循环得到所有的值 那么我们还想把这些值的具体含义也传给函数呢？对吧，万一给他了，他不知道含义瞎解包岂不麻烦 12345678910def my_pow(**var): print(var) if var['height'] &lt; 200: print('矮') if var['weight'] &gt; 50: print('挫') if var['money'] &lt; 1000000000: print('穷') my_pow(height=170, weight=62, money = 30) 1234&#123;'height': 170, 'weight': 62, 'money': 30&#125;矮挫穷 泪！！~，以身教学最为致命。函数的辛酸暂时结束。我们下一节介绍文件处理，就算没学编程，文件大家也都是见过的，如何使用编程语言对文件进行编辑操作才是真正进入工作实用的阶段。再谈递归，如果你是学生，要面试递归就必须掌握的很透，很多面试题用递归都是可以达到简化的效果，工作中倒使用的少，主要就是搬砖嘛。 —欲知后事如何，且听下回分解]]></content>
      <categories>
        <category>Python 教程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[15.Python的循环]]></title>
    <url>%2Fpython%2F15.Python%E7%9A%84%E5%BE%AA%E7%8E%AF.html</url>
    <content type="text"><![CDATA[书接上文Python 循环语句循环是什么？循环就是重复地去做同一件事情，社会的进步一定是解放了生产力。这个知识点你可以在政治课本或者近代工业革命的历史书中了解到。机械代替人类去做一些繁重的工作由来已久，比如用板车代替肩扛运输货物，那么那种循环重复的事情怎么利用机器替代人力呢？像步枪上膛一样，传统机械通过精心的设计可以完成简单的循环，机械上的确实现了往复运动构件，那么每一个任务都要费时费力进行设计。我们不但想让机器代替人类来做体力活，简单的智力活也想让它来做，甚至更复杂的智力工作，这就是人工智能，后面我会用其他篇章来教学。那么我们有了这个思路，我们可以设计让它能够做加法运算，然后在硬件上设置它可以做一个暂时存储，并可以重复这段流程，那么它就可以做所有的加法工作了。 本章节就向大家介绍Python的循环语句，程序在一般情况下是按顺序执行的。 编程语言提供了各种控制结构，允许更复杂的执行路径。循环语句允许我们执行一个语句或语句组多次，有了条件判断和循环，你就可以实现任意负责的执行流程了。听起来是不是很简单，这是因为人的判断本来就很简单，是或者否，然后重复的事情让机器做，设定好你的判断，就不用担心出问题了。下面是在大多数编程语言中的循环语句的一般形式： Python提供了for循环和while循环，python中的循环简化了很多，这对我们学习而言是很有帮助的，假如你去学C++现在恐怕还在看数据类型，，，，严格的语言让机器利用率更高，轻松的语言让人更轻松。 循环类型 描述 while 循环 在给定的判断条件为 true 时执行循环体，否则退出循环体。 for 循环 重复执行语句 嵌套循环 你可以在while循环体中嵌套for循环 循环控制语句循环控制语句可以更改语句执行的顺序。Python支持以下循环控制语句： 控制语句 描述 break 语句 在语句块执行过程中终止循环，并且跳出整个循环 continue 语句 在语句块执行过程中终止当前循环，跳出该次循环，执行下一次循环。 pass 语句 pass是空语句，是为了保持程序结构的完整性。 接下来，让我们进行循环的代码学习 Python while 循环语句while 简单循环123456789101112131415&gt;&gt;&gt; n = 0&gt;&gt;&gt; while n &lt; 10: print(n) n += 10123456789 while 无限循环123456789&gt;&gt;&gt; while 1: a = input('请输入：') if a == 'q': break 请输入：1请输入：2请输入：3请输入：q 到这里好像忘了讲 input 了 ，不过它很简单，这里的代码就是让你输入的的意思，不妨试试，假如去掉判断，那么它就会一直让你输入，成了一个死循环。无限循环一定要加判断，工作中很多糟糕的事情都是循环的锅，比如你想循环剪切一个文件夹到目标文件夹，后来发现没加判断导致所有的内容都剪切过去了，更可怕的是所有的剪切过去没有增量命名，导致所有文件归一，变成一个文件。这些都是我亲身遭遇的。 刚刚好，这里遇到的一个 break ,一个循环控制语句。 还有两个也顺带 过了吧，continue 和 pass 其实这三个语义上都很好理解，我们来试试代码 12345678910111213141516171819&gt;&gt;&gt; while 1: a = input('请输入：') if a == 'c': continue print(a) if a == 'p': pass print(a) if a == 'b': break print(a) 请输入：1请输入：2请输入：3请输入：c请输入：pp请输入：b 看到三者的区别了吧，我们只聊 pass 和 continue , pass就是过啊，过了之后该怎么运行就怎么运行，continue 就是滚回去排队，这次不让你往下走，直接就运行下一个循环了。 Python for 循环语句Python for循环可以遍历任何序列的项目，如一个列表或者一个字符串。 我没记错的话，前面我们谈过一点 for循环，那么我们开始学习代码的编写吧 for 简单循环12345678910111213141516&gt;&gt;&gt; a = [chr(i) for i in range(97,107)]&gt;&gt;&gt; a['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']&gt;&gt;&gt; for i in a: print(i) abcdefghij 还有一种简单常用的的语法： 12345678910111213&gt;&gt;&gt; for i in range(10): print(i) 0123456789 你会发现循环执行了10次，这要比 while 判断循环次数简单许多，这里的 range 其实并不属于序列结构，更准确来说是个生成器，这个概念以后再说。这里你只需要简单知道，生成器就是每次给你一个，这就避免了你想循环100万次，要弄一个长度为100万的列表可不好。就是有了生成器才让 for 几乎可以完全代替while 通常学完循环以后，老师就会用几道 ACM 来虐虐你了，让你严重怀疑你的智商，然后放弃。我觉得这是不人道的，我曾经也是这样然后放弃学编程，直到几年后自学入手才发现妙不可言。如果后面的题让你觉得超过讲解的难度过多，请不要悲伤，没办法，网上都是出这些题，我已经尽力挑简单的了。 1.python 打印等腰直角三角形（记得一本小说，一会儿等腰直角三角形）12345678910s = int(input('输入列数：'))for i in range(s,0,-1): print('*' * i) 输入列数：4********** 2.打印斐波那契数列1234567891011121314斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=3，n∈N*）Fibonacci = [1,1]s = int(input('循环多少次：'))i = 0while i &lt; s: Fibonacci.append( Fibonacci[-1] + Fibonacci[-2]) i += 1print(Fibonacci)循环多少次：10[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144] 列表的可变性好用就在这里，你都不需要考虑其他的，直接后面两个加起来就可以了，简单快捷 打印九九乘法表 1234567891011121314for i in range(1,10): for j in range(1,i+1): print("%d*%d=%d\t"%(i,j,i*j),end=" ") print("") 1*1=1 2*1=2 2*2=4 3*1=3 3*2=6 3*3=9 4*1=4 4*2=8 4*3=12 4*4=16 5*1=5 5*2=10 5*3=15 5*4=20 5*5=25 6*1=6 6*2=12 6*3=18 6*4=24 6*5=30 6*6=36 7*1=7 7*2=14 7*3=21 7*4=28 7*5=35 7*6=42 7*7=49 8*1=8 8*2=16 8*3=24 8*4=32 8*5=40 8*6=48 8*7=56 8*8=64 9*1=9 9*2=18 9*3=27 9*4=36 9*5=45 9*6=54 9*7=63 9*8=72 9*9=81 —欲知后事如何，且听下回分解]]></content>
      <categories>
        <category>Python 教程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[14.Python条件判断]]></title>
    <url>%2Fpython%2F14.Python%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD.html</url>
    <content type="text"><![CDATA[书接上文Python 条件语句Python条件语句是通过一条或多条语句的执行结果（True或者False）来决定执行的代码块。什么意思？就是假如你今天出门，下雨就带伞，不下雨就不带伞。就是一个判断问题，如何让程序实现这种判断呢？1234if 判断条件： 执行语句……else： 执行语句…… 多个判断就用 elif 条件复杂就用上一节提到的逻辑运算符或者位运算符进行辅助。 123456789101112if 判断条件1: 执行语句1……elif 判断条件2: 执行语句2……elif 判断条件3: 执行语句3……else: 执行语句4…… num = 2if num &gt;= 0 and num &lt;= 10: print('hello') 看下面的例子： 12345if 1 &amp; 2: print('a')print('b')&gt;&gt;&gt; b 条件判断 if 后的关系表达式一定是一个可判断的表达式，也就是只能回答真或者假两种情况。只要是满足这个条件都可以当作if 判断的表达式。所以你会看到很多死循环是：while 1 ，而不是 while True. 有什么区别呢？ 数字非0都是True，而True的意思就是非空。在一些条件下，非空比非0可要省事的多，所以很多人喜欢用1 来代替 True 下面用一则简单的程序结束条件判断的学习 123456789101112131415s = '下雨'b = '周末'if b == '周末': if s == '下雨': print('带伞出去玩') else: print('不带伞出去玩')else: if s == '下雨': print('带伞去工作') else: print('不带伞也不工作') &gt;&gt;&gt; 带伞出去玩 程序中错误的逻辑是哪一条？试着分析一下并阐述条件逻辑 程序中最有魅力的就是循环了，可以说循环真正意义上是程序的灵魂，没有循环，如何自动化？如何让机器日复一日的被我们所剥削？下一节好好讲一下循环。学完循环才算是入门了吧。判断在循环中的作用是非常重要的，复杂的循环都要借助判断。就像日复一日的火车运行，有了判断的分叉，才能将人送到幸福的终点。 —欲知后事如何，且听下回分解]]></content>
      <categories>
        <category>Python 教程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[13.Python运算符]]></title>
    <url>%2Fpython%2F13.Python%E8%BF%90%E7%AE%97%E7%AC%A6.html</url>
    <content type="text"><![CDATA[书接上文Python 运算符什么是运算符？本章节主要说明Python的运算符。举个简单的例子 4 +5 = 9 。 例子中，4 和 5 被称为操作数，”+” 称为运算符。Python语言支持以下类型的运算符: 算术运算符 比较（关系）运算符 赋值运算符 逻辑运算符 位运算符 成员运算符 身份运算符 运算符优先级 接下来让我们一个个来学习Python的运算符。 Python算术运算符以下假设变量： a=10，b=20： 运算符 描述 实例 + 加 - 两个对象相加 a + b 输出结果 30 - 减 - 得到负数或是一个数减去另一个数 a - b 输出结果 -10 * 乘 - 两个数相乘或是返回一个被重复若干次的字符串 a * b 输出结果 200 / 除 - x除以y b / a 输出结果 2 % 取模 - 返回除法的余数 b % a 输出结果 0 ** 幂 - 返回x的y次幂 a**b 为10的20次方， 输出结果 100000000000000000000 // 取整除 - 返回商的整数部分（向下取整） &gt;&gt;&gt; 9//2 4 &gt;&gt;&gt; -9//2 -5 注意：python2 和 python 3 有一些小改变，比如整数除整数，python2只能得到整数，python3是可以得到浮点数的 Python比较运算符以下假设变量a为10，变量b为20： 运算符 描述 实例 == 等于 - 比较对象是否相等 (a == b) 返回 False。 != 不等于 - 比较两个对象是否不相等 (a != b) 返回 true. &lt;&gt; 不等于 - 比较两个对象是否不相等 (a &lt;&gt; b) 返回 true。这个运算符类似 != 。 &gt; 大于 - 返回x是否大于y (a &gt; b) 返回 False。 &lt; 小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。 (a &lt; b) 返回 true。 &gt;= 大于等于 - 返回x是否大于等于y。 (a &gt;= b) 返回 False。 &lt;= 小于等于 - 返回x是否小于等于y。 (a &lt;= b) 返回 true。 Python赋值运算符以下假设变量a为10，变量b为20： 运算符 描述 实例 = 简单的赋值运算符 c = a + b 将 a + b 的运算结果赋值为 c += 加法赋值运算符 c += a 等效于 c = c + a -= 减法赋值运算符 c -= a 等效于 c = c - a *= 乘法赋值运算符 c *= a 等效于 c = c * a /= 除法赋值运算符 c /= a 等效于 c = c / a %= 取模赋值运算符 c %= a 等效于 c = c % a **= 幂赋值运算符 c **= a 等效于 c = c ** a //= 取整除赋值运算符 c //= a 等效于 c = c // a Python位运算符按位运算符是把数字看作二进制来进行计算的。Python中的按位运算法则如下： 下表中变量 a 为 60，b 为 13，二进制格式如下： 12345678910111213a = 0011 1100b = 0000 1101-----------------a&amp;b = 0000 1100a|b = 0011 1101a^b = 0011 0001~a = 1100 0011 运算符 描述 实例 &amp; 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0 (a &amp; b) 输出结果 12 ，二进制解释： 0000 1100 | 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。 (a | b) 输出结果 61 ，二进制解释： 0011 1101 ^ 按位异或运算符：当两对应的二进位相异时，结果为1 (a ^ b) 输出结果 49 ，二进制解释： 0011 0001 ~ 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1 。~x 类似于 -x-1 (~a ) 输出结果 -61 ，二进制解释： 1100 0011，在一个有符号二进制数的补码形式。 &lt;&lt; 左移动运算符：运算数的各二进位全部左移若干位，由 &lt;&lt; 右边的数字指定了移动的位数，高位丢弃，低位补0。 a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000 &gt;&gt; 右移动运算符：把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，&gt;&gt; 右边的数字指定了移动的位数 a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111 位运算符可能不是经常用到，但是需要了解到一个点，那就是如果你想让你的程序更加高效，例如判断奇偶性，利用位运算的特性可以快速得出。也可以用于某些内存限制比较严格的领域，比如嵌入式开发当中，状态判别等等。 Python逻辑运算符Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20: 运算符 逻辑表达式 描述 实例 and x and y 布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 (a and b) 返回 20。 or x or y 布尔”或” - 如果 x 是非 0，它返回 x 的值，否则它返回 y 的计算值。 (a or b) 返回 10。 not not x 布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not(a and b) 返回 False Python成员运算符除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。 运算符 描述 实例 in 如果在指定的序列中找到值返回 True，否则返回 False。 x 在 y 序列中 , 如果 x 在 y 序列中返回 True。 not in 如果在指定的序列中没有找到值返回 True，否则返回 False。 x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。 Python身份运算符身份运算符用于比较两个对象的存储单元 运算符 描述 实例 is is 是判断两个标识符是不是引用自一个对象 x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False is not is not 是判断两个标识符是不是引用自不同对象 x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False。 is 与 == 区别： is 用于判断两个变量引用对象是否为同一个(同一块内存空间)， == 用于判断引用变量的值是否相等。 = 与 == 区别： =号是赋值 倒没有难点，主要是很多面试陷阱，容易脱口而出搞混 Python运算符优先级以下表格列出了从最高到最低优先级的所有运算符： 运算符 描述 ** 指数 (最高优先级) ~ + - 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@) * / % // 乘，除，取模和取整除 + - 加法减法 &gt;&gt; &lt;&lt; 右移，左移运算符 &amp; 位 ‘AND’ ^ | 位运算符 &lt;= &lt; &gt; &gt;= 比较运算符 &lt;&gt; == != 等于运算符 = %= /= //= -= += = *= 赋值运算符 is is not 身份运算符 in not in 成员运算符 not and or 逻辑运算符 我自己使用的时候没有记得那么多，可以直接用括号来帮助自己理解逻辑 运算符的学习还是比较简单，主要是大家应该都有数学基础，理解起来并不难。要注意的是，这些运算符并不是所有的对象都可以使用。这里提到这一点是为了后面理解面对对象做铺垫。后面我们自己设计数据类型，可能会发现无法使用这些运算了，这时候就要我们自己写运算告诉计算机我们想要的操作，叫做运算符重载，其实就是向系统借一下这些运算符。 —欲知后事如何，且听下回分解]]></content>
      <categories>
        <category>Python 教程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[11.Python的字典]]></title>
    <url>%2Fpython%2F11.Python%E7%9A%84%E5%AD%97%E5%85%B8.html</url>
    <content type="text"><![CDATA[书接上文接下来讲解第三常用数据结构，字典你心目中前二应该怎么排序？在我的理解里，第二当属列表，它灵活多变，非常多的任务都要通过它来完成。第一毫无疑问就是字符串了，严格意义上来讲，字符串不属于数据结构，因为它的组成还是比较单一的，也没有各种花哨的操作，它组成的天生有序，使得它运用广泛。你所见到的一切不都是它所构成的吗？字符串的重要性不言而喻，对于字符串的操作一定要烂熟于心，这样会省去很多麻烦。 Python 字典(Dictionary)字典是另一种可变容器模型，且可存储任意类型对象。 字典的每个键值 key=&gt;value 对用冒号 : 分割，每个键值对之间用逗号 , 分割，整个字典包括在花括号 {} 中 ,格式如下所示： 1d = &#123;key1 : value1, key2 : value2 &#125; 键一般是唯一的，如果重复最后的一个键值对会替换前面的，值不需要唯一。 12345&gt;&gt;&gt;dict = &#123;'a': 1, 'b': 2, 'b': '3'&#125;&gt;&gt;&gt; dict['b']'3'&gt;&gt;&gt; dict&#123;'a': 1, 'b': '3'&#125; 值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。 又谈到了可变不可变，我们再来理解一下。可变的数据类型其实就是手里多了一根牵牛绳，假如你手里有10根绳子，那就是10头牛，可变就是，你可以随便扔一根，或者再加一根，或者把牛换成羊。你记录的只不过是绳子上的标签，如果牛变成羊了，你把标签换了就可以了，简直太方便管理统计了。 那么字典比较显然了，键就是绳子，所以最后栓的才是显示的值。 列表又如何理解呢？它的键就是它的索引，也就是那个下标啊，这下你知道怎么取值了吧。 访问字典里的值把相应的键放入熟悉的方括弧，是不是很像列表啊 123&gt;&gt;&gt; dict = &#123;'Name': 'Zara', 'Age': 7, 'Class': 'First'&#125;&gt;&gt;&gt; dict['Name']'Zara' 修改字典向字典添加新内容的方法是增加新的键/值对，修改或删除已有键/值对如下实例: 1234567&gt;&gt;&gt; del dict['Name']&gt;&gt;&gt; dict&#123;'Age': 7, 'Class': 'First'&#125;&gt;&gt;&gt; dict.clear()&gt;&gt;&gt; dict&#123;&#125;&gt;&gt;&gt; del dict 这个例子看完，大概精通 del 了吧 警报警报估计很少人仔细看上面的文字内容，为了不踩坑，请仔细理解下面的代码，再回头看看概念 12345678&gt;&gt;&gt; a = &#123;1:1,2:2,3:3,1:4&#125;&gt;&gt;&gt; a&#123;1: 4, 2: 2, 3: 3&#125;&gt;&gt;&gt; b = &#123;[1]:1&#125;Traceback (most recent call last): File "&lt;pyshell#4&gt;", line 1, in &lt;module&gt; b = &#123;[1]:1&#125;TypeError: unhashable type: 'list' 字典内置函数&amp;方法Python字典包含了以下内置函数： 序号 函数及描述 1 len(dict) 计算字典元素个数，即键的总数。 2 str(dict) 输出字典可打印的字符串表示。 3 type(variable) 返回输入的变量类型，如果变量是字典就返回字典类型。 123456789101112&gt;&gt;&gt; dict&#123;'Name': 'Zara', 'Age': 7, 'Class': 'First'&#125;&gt;&gt;&gt; len(dict)3&gt;&gt;&gt; min(dict)'Age'&gt;&gt;&gt; max(dict)'Name'&gt;&gt;&gt; type(dict)&lt;class 'dict'&gt;&gt;&gt;&gt; str(dict)"&#123;'Name': 'Zara', 'Age': 7, 'Class': 'First'&#125;" Python字典包含了以下内置方法： 序号 函数及描述 1 dict.clear() 删除字典内所有元素 2 dict.copy() 返回一个字典的浅复制 3 [dict.fromkeys(seq, val]) 创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值 4 dict.get(key, default=None) 返回指定键的值，如果值不在字典中返回default值 5 dict.has_key(key) 如果键在字典dict里返回true，否则返回false。Python3以后删除了has_key()方法 6 dict.items() 以列表返回可遍历的(键, 值) 元组数组 7 dict.keys() 以列表返回一个字典所有的键 8 dict.setdefault(key, default=None) 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default 9 dict.update(dict2) 把字典dict2的键/值对更新到dict里 10 dict.values() 以列表返回字典中的所有值 11 [pop(key,default]) 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。 12 popitem() 随机返回并删除字典中的一对键和值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&gt;&gt;&gt; dict&#123;'Name': 'Zara', 'Age': 7, 'Class': 'First'&#125;&gt;&gt;&gt; dict.clear()&gt;&gt;&gt; dict&#123;&#125;&gt;&gt;&gt; a = dict.fromkeys(range(97,100),[chr(i) for i in range(97,100)])&gt;&gt;&gt; a&#123;97: ['a', 'b', 'c'], 98: ['a', 'b', 'c'], 99: ['a', 'b', 'c']&#125;&gt;&gt;&gt; b = a&gt;&gt;&gt; b[97] = 0&gt;&gt;&gt; b&#123;97: 0, 98: ['a', 'b', 'c'], 99: ['a', 'b', 'c']&#125;&gt;&gt;&gt; a&#123;97: 0, 98: ['a', 'b', 'c'], 99: ['a', 'b', 'c']&#125;&gt;&gt;&gt; c = a.copy()&gt;&gt;&gt; c[97] = 100&gt;&gt;&gt; c&#123;97: 100, 98: ['a', 'b', 'c'], 99: ['a', 'b', 'c']&#125;&gt;&gt;&gt; a&#123;97: 0, 98: ['a', 'b', 'c'], 99: ['a', 'b', 'c']&#125;&gt;&gt;&gt; a&#123;97: 0, 98: ['a', 'b', 'c'], 99: ['a', 'b', 'c']&#125;&gt;&gt;&gt; a.get(97)0&gt;&gt;&gt; a.get(90)&gt;&gt;&gt; b = a.get(90)&gt;&gt;&gt; b&gt;&gt;&gt; a.get(90,default='hehe')Traceback (most recent call last): File "&lt;pyshell#14&gt;", line 1, in &lt;module&gt; a.get(90,default='hehe')TypeError: get() takes no keyword arguments &gt;&gt;&gt; 97 in aTrue&gt;&gt;&gt; a&#123;97: 0, 98: ['a', 'b', 'c'], 99: ['a', 'b', 'c']&#125;&gt;&gt;&gt; b = a.items()&gt;&gt;&gt; bdict_items([(97, 0), (98, ['a', 'b', 'c']), (99, ['a', 'b', 'c'])])&gt;&gt;&gt; type(b)&lt;class 'dict_items'&gt;&gt;&gt;&gt; c = a.keys()&gt;&gt;&gt; cdict_keys([97, 98, 99])&gt;&gt;&gt; d = a.values()&gt;&gt;&gt; ddict_values([0, ['a', 'b', 'c'], ['a', 'b', 'c']])&gt;&gt;&gt; a&#123;97: 0, 98: ['a', 'b', 'c'], 99: ['a', 'b', 'c']&#125;&gt;&gt;&gt; a.setdefault(100,100)100&gt;&gt;&gt; a&#123;97: 0, 98: ['a', 'b', 'c'], 99: ['a', 'b', 'c'], 100: 100&#125;&gt;&gt;&gt; a = &#123;97: 0, 98: ['a', 'b', 'c'], 99: ['a', 'b', 'c']&#125;&gt;&gt;&gt; b = &#123;97:100&#125;&gt;&gt;&gt; a.update(b)&gt;&gt;&gt; a&#123;97: 100, 98: ['a', 'b', 'c'], 99: ['a', 'b', 'c']&#125;&gt;&gt;&gt; a.pop(97,66)100&gt;&gt;&gt; a&#123;98: ['a', 'b', 'c'], 99: ['a', 'b', 'c']&#125;&gt;&gt;&gt; a.pop(97,66)66&gt;&gt;&gt; a.popitem()(99, ['a', 'b', 'c'])&gt;&gt;&gt; a&#123;98: ['a', 'b', 'c']&#125; 字典相对而言比较复杂，具有一定的难度，主要的难点在于密集恐惧。看见这么多括号，逗号，冒号，的确是有点冒火。难倒不难，还是比较有层次结构的一种数据类型。重点理解 fromkeys , get , setdefault , pop , popitem 的易错点，还要理解为什么部分方法会有返回值呢？ 其实系统自带的库函数，输入输出还是挺讲究的，不会无缘无故返回一个你用不到的值。除了哪些大家都烂熟的功能，大部分函数，包括你未来要写的代码，一定要有返回值，也就是输出。否则像列表这种原地操作，可是很容易出现问题，程序还不报错，灭BUG就幸苦了。 重点理解字典的可变和函数方法，我们下一节，先休息一下，做点复习。然后正式向程序编程出发 —欲知后事如何，且听下回分解]]></content>
      <categories>
        <category>Python 教程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[10.Python的元组]]></title>
    <url>%2Fpython%2F10.Python%E7%9A%84%E5%85%83%E7%BB%84.html</url>
    <content type="text"><![CDATA[书接上文上一节谈到了列表，这一节聊一下元组，初学的时候，元组和列表类似，所以我们快速过一遍。然后结合前面的内容来一些习题进行巩固。Python 元组Python的元组与列表类似，不同之处在于元组的元素不能修改。元组使用小括号，列表使用方括号。元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。 123tup1 = ('physics', 'chemistry', 1997, 2000)tup2 = (1, 2, 3, 4, 5 )tup3 = "a", "b", "c", "d" 注意到tup3没有加括号，这里是省略掉了，后面我们学习函数传参的时候就能够理解这种简写的方式是非常简洁的 创建空元组 1tup1 = () 元组中只包含一个元素时，需要在元素后面添加逗号 1tup1 = (50,) 这里一定要注意，逗号是必不可少的。否则它就是一个数学括号了，为了避免混淆，所以语法定义必须加上。如果你读过大量的代码，你会发现，很多程序员都喜欢在结束的地方加上逗号，这是个不错的习惯，正好可以避免元组生成的问题 访问元组1234567&gt;&gt;&gt; a = (1 , 2 , 3 , 4, )&gt;&gt;&gt; a(1, 2, 3, 4)&gt;&gt;&gt; a[0]1&gt;&gt;&gt; a[::-1](4, 3, 2, 1) 和列表一样 修改元组元组中的元素值是不允许修改的，但我们可以对元组进行连接组合 123456789101112&gt;&gt;&gt; a(1, 2, 3, 4)&gt;&gt;&gt; b[0, 1, 2, 3]&gt;&gt;&gt; b[0] = 4&gt;&gt;&gt; b[4, 1, 2, 3]&gt;&gt;&gt; a[0] = 4Traceback (most recent call last): File "&lt;pyshell#11&gt;", line 1, in &lt;module&gt; a[0] = 4TypeError: 'tuple' object does not support item assignment 看见列表和元组的区别了吗？这是它们的第一个不同点，你也可以元组生产式对列表进行转换再拼接 123&gt;&gt;&gt; a += tuple(b)&gt;&gt;&gt; a(1, 2, 3, 4, 4, 1, 2, 3) 删除元组元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组，如下实例: 123456789&gt;&gt;&gt; a = tuple(range(10))&gt;&gt;&gt; a(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)&gt;&gt;&gt; del a&gt;&gt;&gt; aTraceback (most recent call last): File "&lt;pyshell#3&gt;", line 1, in &lt;module&gt; aNameError: name 'a' is not defined 元组运算符与字符串一样，元组之间可以使用 + 号和 * 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组 Python 表达式 结果 描述 len((1, 2, 3)) 3 计算元素个数 (1, 2, 3) + (4, 5, 6) (1, 2, 3, 4, 5, 6) 连接 (‘Hi!’,) * 4 (‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’) 复制 3 in (1, 2, 3) True 元素是否存在 for x in (1, 2, 3): print x, 1 2 3 迭代 无关闭分隔符任意无符号的对象，以逗号隔开，默认为元组 12345678910&gt;&gt;&gt; a , b = 1 , 2&gt;&gt;&gt; a1&gt;&gt;&gt; b2&gt;&gt;&gt; a , b = b , a&gt;&gt;&gt; a2&gt;&gt;&gt; b1 元组的解包操作非常方便互换两元素的值。通常来讲，你要互换两杯水，你得另找一个杯子做过度。这里深处的原理我们后面再讲 元组内置函数 序号 方法及描述 1 len(tuple) 计算元组元素个数。 2 max(tuple) 返回元组中元素最大值。 3 min(tuple) 返回元组中元素最小值。 4 tuple(seq) 将列表转换为元组。 还记得之前谈过的列表和字符串方法和函数吗，你姑且认为函数就是别人家的高压锅。所以，你可以用这些函数得到元组食材的某些属性，这些属性在很多食材上面都有所体现。所以我们特制这个函数锅。 123456789&gt;&gt;&gt; a = tuple(range(10))&gt;&gt;&gt; a(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)&gt;&gt;&gt; min(a)0&gt;&gt;&gt; max(a)9&gt;&gt;&gt; len(a)10 作业：查询元组函数，并进行实践，注意观察和列表的不同。想一想，为什么要定义这些差别。并复习列表，深刻体会列表的可变特性。 1234567891011121314151617&gt;&gt;&gt; a = 'hello'&gt;&gt;&gt; len(a,)5&gt;&gt;&gt; b = a,&gt;&gt;&gt; len(b)1&gt;&gt;&gt; A,B,C,D,E = tuple(a)&gt;&gt;&gt; A'h'&gt;&gt;&gt; B'e'&gt;&gt;&gt; C'l'&gt;&gt;&gt; D'l'&gt;&gt;&gt; E'o' 注意小细节 —欲知后事如何，且听下回分解]]></content>
      <categories>
        <category>Python 教程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[12.复习]]></title>
    <url>%2Fpython%2F12.%E5%A4%8D%E4%B9%A0.html</url>
    <content type="text"><![CDATA[前面的内容都比较简单，多敲敲就会了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[9.Python 的列表]]></title>
    <url>%2Fpython%2F9.Python%20%E7%9A%84%E5%88%97%E8%A1%A8.html</url>
    <content type="text"><![CDATA[书接上文Python 列表(List)序列是Python中最基本的数据结构。序列中的每个元素都分配一个数字 - 它的位置，或索引，第一个索引是0，第二个索引是1，依此类推。Python有6个序列的内置类型，但最常见的是列表和元组。序列都可以进行的操作包括索引，切片，加，乘，检查成员。此外，Python已经内置确定序列的长度以及确定最大和最小的元素的方法。 列表是最常用的Python数据类型，它可以作为一个方括号内的逗号分隔值出现。 列表的数据项不需要具有相同的类型 创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。如下所示： 123list1 = ['physics', 'chemistry', 1997, 2000]list2 = [1, 2, 3, 4, 5 ]list3 = ["a", "b", "c", "d"] 与字符串的索引一样，列表索引从0开始。列表可以进行截取、组合等。 先来介绍一下常用的列表操作 访问列表中的值用索引和切片进行访问就可以了，和字符串一样 12345&gt;&gt;&gt; a = [1 , 2 , 3 , 4 , 5]&gt;&gt;&gt; a[0]1&gt;&gt;&gt; a[-1]5 12&gt;&gt;&gt; a[::-1][5, 4, 3, 2, 1] 更新列表你可以对列表的数据项进行修改或更新，你也可以使用append()方法来添加列表项，如下所示： 12345&gt;&gt;&gt; list = []&gt;&gt;&gt; list.append('a')&gt;&gt;&gt; list.append('b')&gt;&gt;&gt; list['a', 'b'] 这里可以看到 list 不是保留字，所以可以拿来当变量名，不过不建议你这样做，除非有别的原因，更推荐你用它当前缀和后缀，方便代码阅读 删除列表元素可以使用 del 语句来删除列表的元素，如下实例： 12345&gt;&gt;&gt; a[1, 2, 3, 4, 5]&gt;&gt;&gt; del a[0]&gt;&gt;&gt; a[2, 3, 4, 5] 虽然我们还没有讲到循环，和列表生成，不过讲到这里，有一个知识点提一下，方便大家对于列表的本质进行理解 123&gt;&gt;&gt; a = list(range(20))&gt;&gt;&gt; a[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19] 有这样一个列表 a 如果你想删除前面 10 个 怎么做呢？ 123456&gt;&gt;&gt; a = list(range(20))&gt;&gt;&gt; a[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]&gt;&gt;&gt; for i in range(10): del a[i]这个循环的意思是，i的取值从0到10之间，每循环一次，删除一个元素 这样做正确吗？ 我们来看看答案 12&gt;&gt;&gt; a[1, 3, 5, 7, 9, 11, 13, 15, 17, 19] 其实这里就好像删除一个，后面就补上了，这样，del 每次跑过来说我要删第下一个了，却忘了列表已经不是以前的列表了。讲到这里你大概理解一下列表是可变序列这个定义 列表脚本操作符列表对 + 和 * 的操作符与字符串相似。+ 号用于组合列表，* 号用于重复列表。 如下所示： Python 表达式 结果 描述 len([1, 2, 3]) 3 长度 [1, 2, 3] + [4, 5, 6] [1, 2, 3, 4, 5, 6] 组合 [‘Hi!’] * 4 [‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’] 重复 3 in [1, 2, 3] True 元素是否存在于列表中 for x in [1, 2, 3]: print x, 1 2 3 迭代 Python列表函数&amp;方法Python包含以下函数: 序号 函数 1 len(list) 列表元素个数 2 max(list) 返回列表元素最大值 3 min(list) 返回列表元素最小值 4 list(seq) 将元组转换为列表 1234567891011&gt;&gt;&gt; a[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]&gt;&gt;&gt; len(a)10&gt;&gt;&gt; max(a)19&gt;&gt;&gt; min(a)1&gt;&gt;&gt; s = 'hello world'&gt;&gt;&gt; list(s)['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd'] Python包含以下方法: 序号 方法 1 list.append(obj) 在列表末尾添加新的对象 2 list.count(obj) 统计某个元素在列表中出现的次数 3 list.extend(seq) 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表） 4 list.index(obj) 从列表中找出某个值第一个匹配项的索引位置 5 list.insert(index, obj) 将对象插入列表 6 [list.pop(index=-1]) 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值 7 list.remove(obj) 移除列表中某个值的第一个匹配项 8 list.reverse() 反向列表中元素 9 list.sort(cmp=None, key=None, reverse=False) 对原列表进行排序 123456789101112131415161718192021222324252627282930313233.&gt;&gt;&gt; a = [i for i in range(10)]&gt;&gt;&gt; a[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt;&gt; a.append(10)&gt;&gt;&gt; a[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&gt;&gt;&gt; a.count(5)1&gt;&gt;&gt; b = [11 , 12]&gt;&gt;&gt; a.extend(b)&gt;&gt;&gt; a[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]&gt;&gt;&gt; a.index(10)10&gt;&gt;&gt; a.insert(20,2)&gt;&gt;&gt; a[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 2]&gt;&gt;&gt; a.insert(2,20)&gt;&gt;&gt; a[0, 1, 20, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 2]&gt;&gt;&gt; a.remove(20)&gt;&gt;&gt; a[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 2]&gt;&gt;&gt; a.reverse()&gt;&gt;&gt; a[2, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]&gt;&gt;&gt; a.sort()&gt;&gt;&gt; a[0, 1, 2, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]&gt;&gt;&gt; a.sort(reverse = True)&gt;&gt;&gt; a[12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 2, 1, 0] 请注意，列表的 a 的值的变化，我们始终是在 a 的自身上进行操作，并不是复制一份，操作完 a 不变，而是可变的，再说一遍，列表是可变序列。还要注意哪些操作是没有返回结果的，哪些是有返回结果的。 其实，在学习工作的过程中，对于一个函数，最重要的就是，输入？ 输出？ 注释？，有了这三点的函数，才是一个合格的函数 方法？函数？有区别吗？ 暂时你就当作函数是别人的高压锅，方法是你自己家的调料和食材。你看函数通常就是把你的食材放进去，方法就是每次放一点调味料。 12345678910&gt;&gt;&gt; a[12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 2, 1, 0]&gt;&gt;&gt; a.pop()0&gt;&gt;&gt; a[12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 2, 1]&gt;&gt;&gt; a.pop(0)12&gt;&gt;&gt; a[11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 2, 1] 为什么pop要单独放出来？ 确实是忘了。。。 既然拿出来了，顺便抛砖引玉说一下，入栈出栈。就是说你去买香辣酱香饼，烙的一层一层堆那么高，你也不能指定只要最下面的那层吧，会被打死的。最妥的办法就是你买最上面一层，老板烙好饼继续堆上去。这里就是 pop 和 append ，所以不建议你 pop(0)。 这就是数据结构的魅力 还是这个烙饼大叔，因为你的光顾，大叔决定开店让顾客坐下来吃饼。体会大饼的斯过咦。店不大，只能容纳百来号人，大家有序点饼，吃完就走。爆满的时候，后面就等着，吃完一个走一个，走一个进一个，这就是队列。 下一节讲元组，和列表差不太多，我觉得是要比列表学起来简单，敬请期待。 —欲知后事如何，且听下回分解]]></content>
      <categories>
        <category>Python 教程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[8.Python的字符串]]></title>
    <url>%2Fpython%2F8.Python%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2.html</url>
    <content type="text"><![CDATA[书接上文在学习新的内容之前，我们做一个小校验，看看自己前面的数值类型是否掌握。 123456789&gt; 1.把你的名字拼音用编码数字进行输出&gt; 2.把上一题的编码解析出来，你或许以后可以用这个当成你的某网站密码&gt; 3.数字3.1向上取整&gt; 4.数字4.9向下取整&gt; 5.数字5.555保留两位小数&gt; 6.把你名字的数字编码转为二进制，八进制，十六进制&gt; 7.将数字8.88转为整型&gt; 8.将字符串的python语句转为正常语句，再赋给一个字符串&gt; Python 字符串字符串是 Python 中最常用的数据类型。我们可以使用引号(‘或”)来创建字符串。 创建字符串很简单，只要为变量分配一个值即可。例如： 12s1 = 'Hello's2 = "world" Python访问字符串中的值Python不支持单字符类型，单字符在 Python 中也是作为一个字符串使用。 Python访问子字符串，可以使用方括号来截取字符串，如下实例： 12345678910111213&gt;&gt;&gt; a = 'Hello world'&gt;&gt;&gt; a[0]'H'&gt;&gt;&gt; a[-1]'d'&gt;&gt;&gt; a[0:-1]'Hello worl'&gt;&gt;&gt; a[:]'Hello world'&gt;&gt;&gt; a[::-1]'dlrow olleH'&gt;&gt;&gt; a[::2]'Hlowrd' 注意是怎么将字符串反转的语法。 Python字符串更新123456789&gt;&gt;&gt; a = 'Hello world'&gt;&gt;&gt; a[0] = 'C'Traceback (most recent call last): File "&lt;pyshell#2&gt;", line 1, in &lt;module&gt; a[0] = 'C'TypeError: 'str' object does not support item assignment&gt;&gt;&gt; b = a[0] + 'C'&gt;&gt;&gt; b'HC' 字符串是不能直接修改的，原因和总结，学习完基本类型后会进行说明。但是你可以访问得到它的值然后赋给其他变量 Python转义字符 转义字符 描述 \(在行尾时) 续行符 \\ 反斜杠符号 \‘ 单引号 \“ 双引号 \a 响铃 \b 退格(Backspace) \e 转义 \000 空 \n 换行 \v 纵向制表符 \t 横向制表符 \r 回车 \f 换页 \oyy 八进制数，yy代表的字符，例如：\o12代表换行 \xyy 十六进制数，yy代表的字符，例如：\x0a代表换行 \other 其它的字符以普通格式输出 用的较多的是 \n 和 \t Python字符串运算符下表实例变量 a 值为字符串 “Hello”，b 变量值为 “Python”： 操作符 描述 实例 + 字符串连接 &gt;&gt;&gt;a + b ‘HelloPython’ * 重复输出字符串 &gt;&gt;&gt;a * 2 ‘HelloHello’ [] 通过索引获取字符串中字符 &gt;&gt;&gt;a[1] ‘e’ [ : ] 截取字符串中的一部分 &gt;&gt;&gt;a[1:4] ‘ell’ in 成员运算符 - 如果字符串中包含给定的字符返回 True &gt;&gt;&gt;”H”in a True not in 成员运算符 - 如果字符串中不包含给定的字符返回 True &gt;&gt;&gt;”M” not in a True r/R 原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 &gt;&gt;&gt;print(r’\n’ \n)&gt;&gt;&gt; print(R’\n’ ) % 格式字符串 请看下一章节 Python 字符串格式化如果我们想让字符串可以随时变化，就像很多网站当你登录的时候都会说，欢迎您，[你的用户名]，那就要用到字符串格式化，这样表达有点抽象，也就是说你想让字符串哪里变化，不妨在那个位置上留点东西，像图书馆占位置一样。也不能随便留，你要留点象征性的东西嘛，这样它看到你留的记号就知道这里是给它占的位置。 python 字符串格式化符号: 符 号 描述 %c 格式化字符及其ASCII码 %s 格式化字符串 %d 格式化整数 %u 格式化无符号整型 %o 格式化无符号八进制数 %x 格式化无符号十六进制数 %X 格式化无符号十六进制数（大写） %f 格式化浮点数字，可指定小数点后的精度 %e 用科学计数法格式化浮点数 %E 作用同%e，用科学计数法格式化浮点数 %g %f和%e的简写 %G %F 和 %E 的简写 %p 用十六进制数格式化变量的地址 格式化操作符辅助指令: 符号 功能 * 定义宽度或者小数点精度 - 用做左对齐 + 在正数前面显示加号( + ) 在正数前面显示空格 # 在八进制数前面显示零(‘0’)，在十六进制前面显示’0x’或者’0X’(取决于用的是’x’还是’X’) 0 显示的数字前面填充’0’而不是默认的空格 % ‘%%’输出一个单一的’%’ (var) 映射变量(字典参数) m.n. m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话) Python三引号python三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。 三引号的语法是一对连续的单引号或者双引号（通常都是成对的用） 那些地方使用较多呢？通常在大段大段的说明使用较多，根本不像注释了，几乎就是帮助文档。还有就是很复杂的长字符串，比如下面这样的html页面，和SQL执行语句，常规的单双引简直没法处理 1234567891011121314151617errHTML = '''&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Friends CGI Demo&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H3&gt;ERROR&lt;/H3&gt;&lt;B&gt;%s&lt;/B&gt;&lt;P&gt;&lt;FORM&gt;&lt;INPUT TYPE=button VALUE=BackONCLICK="window.history.back()"&gt;&lt;/FORM&gt;&lt;/BODY&gt;&lt;/HTML&gt;'''cursor.execute('''CREATE TABLE users ( login VARCHAR(8), uid INTEGER,prid INTEGER)''') Unicode 字符串12&gt;&gt;&gt; u'Hello World !'u'Hello World !' python的字符串内建函数这部分内容较多，先附上总表，然后我们一起在交互环境中多敲敲，逐步攻破 方法 描述 string.capitalize() 把字符串的第一个字符大写 string.center(width) 返回一个原字符串居中,并使用空格填充至长度 width 的新字符串 string.count(str, beg=0, end=len(string)) 返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数 string.decode(encoding=’UTF-8’, errors=’strict’) 以 encoding 指定的编码格式解码 string，如果出错默认报一个 ValueError 的 异 常 ， 除非 errors 指 定 的 是 ‘ignore’ 或 者’replace’ string.encode(encoding=’UTF-8’, errors=’strict’) 以 encoding 指定的编码格式编码 string，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’ string.endswith(obj, beg=0, end=len(string)) 检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False. string.expandtabs(tabsize=8) 把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8。 string.find(str, beg=0, end=len(string)) 检测 str 是否包含在 string 中，如果 beg 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回-1 string.format() 格式化字符串 string.index(str, beg=0, end=len(string)) 跟find()方法一样，只不过如果str不在 string中会报一个异常. string.isalnum() 如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True,否则返回 False string.isalpha() 如果 string 至少有一个字符并且所有字符都是字母则返回 True,否则返回 False string.isdecimal() 如果 string 只包含十进制数字则返回 True 否则返回 False. string.isdigit() 如果 string 只包含数字则返回 True 否则返回 False. string.islower() 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False string.isnumeric() 如果 string 中只包含数字字符，则返回 True，否则返回 False string.isspace() 如果 string 中只包含空格，则返回 True，否则返回 False. string.istitle() 如果 string 是标题化的(见 title())则返回 True，否则返回 False string.isupper() 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False string.join(seq) 以 string 作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串 string.ljust(width) 返回一个原字符串左对齐,并使用空格填充至长度 width 的新字符串 string.lower() 转换 string 中所有大写字符为小写. string.lstrip() 截掉 string 左边的空格 string.maketrans(intab, outtab]) maketrans() 方法用于创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。 max(str) 返回字符串 str 中最大的字母。 min(str) 返回字符串 str 中最小的字母。 string.partition(str) 有点像 find()和 split()的结合体,从 str 出现的第一个位置起,把 字 符 串 string 分 成 一 个 3 元 素 的 元 组 (string_pre_str,str,string_post_str),如果 string 中不包含str 则 string_pre_str == string. string.replace(str1, str2, num=string.count(str1)) 把 string 中的 str1 替换成 str2,如果 num 指定，则替换不超过 num 次. string.rfind(str, beg=0,end=len(string) ) 类似于 find()函数，不过是从右边开始查找. string.rindex( str, beg=0,end=len(string)) 类似于 index()，不过是从右边开始. string.rjust(width) 返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串 string.rpartition(str) 类似于 partition()函数,不过是从右边开始查找 string.rstrip() 删除 string 字符串末尾的空格. string.split(str=””, num=string.count(str)) 以 str 为分隔符切片 string，如果 num 有指定值，则仅分隔 num+ 个子字符串 string.splitlines([keepends]) 按照行(‘\r’, ‘\r\n’, \n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。 string.startswith(obj, beg=0,end=len(string)) 检查字符串是否是以 obj 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查. string.strip([obj]) 在 string 上执行 lstrip()和 rstrip() string.swapcase() 翻转 string 中的大小写 string.title() 返回”标题化”的 string,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle()) string.translate(str, del=””) 根据 str 给出的表(包含 256 个字符)转换 string 的字符,要过滤掉的字符放到 del 参数中 string.upper() 转换 string 中的小写字母为大写 string.zfill(width) 返回长度为 width 的字符串，原字符串 string 右对齐，前面填充0 下面是我的示例代码，均是用jupyter编写： 1a = 'the answer to life the universe and everything' 1a.capitalize() 1'The answer to life the universe and everything' 1a.count('a',0,20) 11 1b = a.encode(encoding='UTF-8') 1b 1b'the answer to life the universe and everything' 1c = b.decode(encoding='UTF-8') 1c 1'the answer to life the universe and everything' 1a.endswith('g') 1True 1a.startswith('g') 1False 1a.expandtabs(tabsize=8) 1'the answer to life the universe and everything' 1a.find('the',0,42) # 如果是返回开始的索引 10 1fs = '&#123;&#125;'.format('hello') 1fs 1'hello' 1a.index('an') 14 1a.isalnum() 1False 1a.isalpha() 1False 1a.isdecimal() 1False 1a.isdigit() 1False 1d = '0b110' 1d.isalnum() 1True 1d.isdecimal() 1False 1d.isdigit() 1False 1a.islower() 1True 1a.isnumeric() 1False 1a.isspace() 1False 1a.istitle() 1False 1a.isupper() 1False 1' '.join(['a','b']) 1'a b' 1a.ljust(60) 1'the answer to life the universe and everything ' 1a.lower() 1'the answer to life the universe and everything' 1a.lstrip() 1'the answer to life the universe and everything' 1a.maketrans('the','CCC') # 两个字符串必须相等长度 1&#123;116: 67, 104: 67, 101: 67&#125; 1ord('t') 1116 1max(a) 1'y' 1min(a) 1' ' 1a.partition('and') 1('the answer to life the universe ', 'and', ' everything') 1a.replace('the','The',a.count('the')) 1'The answer to life The universe and everything' 1a.rfind('a') 132 1a.rindex('a') 132 1a.rjust(60) 1' the answer to life the universe and everything' 1a.rpartition('the') 1('the answer to life ', 'the', ' universe and everything') 1a.rstrip() 1'the answer to life the universe and everything' 1a.split('a',1) 1['the ', 'nswer to life the universe and everything'] 12345s = '''i \nam a \nstudent''' 1sp1 = s.splitlines() 1sp1 1['', 'i ', '', 'am a ', '', 'student'] 1sp2 = s.splitlines(True) 1sp2 1['\n', 'i \n', '\n', 'am a \n', '\n', 'student\n'] 1a.strip() 1'the answer to life the universe and everything' 1a.title() 1'The Answer To Life The Universe And Everything' 1a.upper() 1'THE ANSWER TO LIFE THE UNIVERSE AND EVERYTHING' 1a.zfill(60) 1'00000000000000the answer to life the universe and everything' 123strs = "this is string example....wow!!!"trantab = str.maketrans('aeiou','12345')strs.translate(trantab) 1'th3s 3s str3ng 2x1mpl2....w4w!!!' 大概也就这么多了，多加练习就可以了。 —欲知后事如何，且听下回分解]]></content>
      <categories>
        <category>Python 教程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何使用SVM训练自己的数据]]></title>
    <url>%2Freading%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8SVM%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%B0%E6%8D%AE.html</url>
    <content type="text"><![CDATA[如何使用SVM训练自己的数据1.分析数据示例数据集使用的是 CSV 文件（以逗号为分隔符的文本文件）数据集：标签文件2.导入相关模块12345678from sklearn.externals import joblib # 保存加载模型时使用from sklearn.model_selection import train_test_split # 划分数据集from sklearn.model_selection import GridSearchCV # 网格搜索最优参数from sklearn.svm import SVC # 导入 SVM 算法模块from sklearn.metrics import classification_report # 生成训练结果报告import pandas as pdimport numpy as np # 这个可以不用，我手滑习惯性都导入，新版的pandas改版了许多兼容numpy的类型，以前是很依赖numpy的，所以普遍教程都是先教你numpy再教你pandas。现在基本上numpy能做的pandas都能做，既独立，又兼容。 3.载入数据12X = pd.read_csv('histocsv.csv').astype('float32')Y = pd.read_csv('histocsv_labels.csv').astype('float32') 因为我的数据里面同字段的数值类型不一样，所以导入的时候统一转换成了 float32 如果你不确定自己的字段是否一致，可以用类似下面的语句进行校验 12345678&gt;&gt;&gt; X.dtypesOut[]: 145 float3235 float3240 float3253 float3274 float3274.1 float32 产看数据维度是否对应 1234&gt;&gt;&gt; X.shapeOut[]: (35153, 257)&gt;&gt;&gt; Y.shapeOut[]: (35153, 1) 取出你感兴趣的字段，我这里因为之前做 CSV 文件的时候，自己每一行结束写了 ‘\n’ ,所以我少取一列 4.取出想要训练的数据12x = X.values[:,:256]y = Y.values.ravel() 这里有一个坑，虽然你的标签数据只是一列，显示的形状也是（None,1),但是实际训练需要的维度是（None,)，尽管表现是一样的，实际上却会报错。所以在取到 Value 的同时还需要 ravel 一下。这里还有一个坑，我们取值的时候，使用了 values ，不使用会报错的，因为这里的默认类型是 Dataframe , 需要转成 dnarray 类型。使用values可以直接转 5.划分数据集12345train_x,test_x,train_y,test_y = train_test_split( x,y, test_size=0.2, shuffle=True, random_state=42) 将你的数据进行划分，默认情况 shuffle 是会打乱的，random_state建议设为42，因为这是宇宙一切问题的终极答案，划分比例随意，实践大多数都是 0.2 ，0.3左右 6.设置网格搜索的超参数1234turn_parameters = [ &#123;'kernel' : ['rbf'], 'gamma':[1e-3, 1e-4], 'C':[1,10,100,1000]&#125;, &#123;'kernel':['linear'], 'C':[1,10,100,1000]&#125;] 7.调用网格搜索模块将上面设置的超参数放入网格搜索，让训练按照你设置的参数进行 1clf = GridSearchCV(SVC(C=1), turn_parameters, cv=5) cv就是交叉验证的意思，5就是5折，意思数据分5块，这样你的训练就有80%的量 8.进行训练1clf.fit(train_x,train_y) fit 虽然是一个简单的函数，使用非常方便，但是有兴趣可以看看内部的源码，结构设计非常独特，整个fit家族貌合神离。 9.输出最佳参数1print(clf.best_params_) 10.预测结果和分类报告12y_true, y_pred = test_y, clf.predict(test_x)print(classification_report(y_true, y_pred)) 11.完整代码12345678910111213141516171819202122232425262728293031323334353637# -*- coding: utf-8 -*-"""Created on Wed Aug 21 16:02:53 2019@author: CC"""from sklearn.externals import joblibfrom sklearn import preprocessingimport pandas as pdfrom sklearn.model_selection import train_test_splitfrom sklearn.model_selection import GridSearchCVfrom sklearn.metrics import classification_reportfrom sklearn.svm import SVCimport numpy as npX = pd.read_csv('histocsv.csv').astype('float32')Y = pd.read_csv('histocsv_labels.csv').astype('float32')x = X.values[:,:256]y = Y.values.ravel()train_x,test_x,train_y,test_y = train_test_split( x,y,test_size=0.25,shuffle=True,random_state=42)turn_parameters = [ &#123;'kernel' : ['rbf'], 'gamma':[1e-3, 1e-4], 'C':[1,10,100,1000]&#125;, &#123;'kernel':['linear'], 'C':[1,10,100,1000]&#125;]clf = GridSearchCV(SVC(C=1), turn_parameters, cv=5)clf.fit(train_x,train_y)print(clf.best_params_)#分类报告y_true, y_pred = test_y, clf.predict(test_x)print(classification_report(y_true, y_pred)) 12.保存和加载模型因为整个训练过程也不是每次都要保存，通常是有了重大突破的时候才需要保存模型，所以简单介绍一下，模型的保存和加载。为方便理解，使用了自带的 iris 花数据集 第一种方法是利用上面导入的 joblib 模块12345678910111213141516171819202122232425from sklearn.externals import joblibfrom sklearn.svm import SVCfrom sklearn import datasets # 定义分类器svm = SVC() # 加载iris数据集iris = datasets.load_iris()# 读取特征X = iris.data# 读取分类标签Y = iris.target # 训练模型svm.fit(X, Y) # 保存成sklearn自带的文件格式joblib.dump(svm, 'svm.pkl') # 加载svm.pklnew_svm = joblib.load('svm.pkl')print(new_svm.predict(X[0:1])) 第二种方法是使用pickle模块这个泡菜模块经常用来做数据打包 123456789101112131415161718192021222324252627import picklefrom sklearn.svm import SVCfrom sklearn import datasets # 定义分类器svm = SVC() # 加载iris数据集iris = datasets.load_iris()# 读取特征X = iris.data# 读取分类标签Y = iris.target # 训练模型svm.fit(X, Y) # 保存成python支持的文件格式picklewith open('svm.pickle', 'wb') as fw: pickle.dump(svm, fw) # 加载svm.picklewith open('svm.pickle', 'rb') as fr: new_svm = pickle.load(fr) print(new_svm.predict(X[0:1])) 13.知识扩展SVM是机器学习中分类和回归的算法之一，中文译为支持向量机。 SVM用于分类，名称为SVC，用于回归，名称为SCR SVM的基本概念 分隔超平面：将数据集分割开来的直线叫做分隔超平面。 超平面：如果数据集是N维的，那么就需要N-1维的某对象来对数据进行分割。该对象叫做超平面，也就是分类的决策边界。 间隔：一个点到分割面的距离，称为点相对于分割面的距离。 数据集中所有的点到分割面的最小间隔的2倍，称为分类器或数据集的间隔。 最大间隔：SVM分类器是要找最大的数据集间隔。 支持向量：坐落在数据边际的两边超平面上的点被称为支持向量 为什么要求最大间隔： 其实一个机器学习问题可能存在多解，我们想要找到的是最优的那个解，于是我们权衡，首先这个分类的平面要能够正确把两堆数据进行划分，其次我们希望两团数据难以区分的那些数据也就是支持向量距离这个平面的距离要足够远。这样得到的超平面就是最佳平面了。 软间隔和硬间隔：不可避免你的数据可能存在错误数据和采样误差，可能在事实上本来就区分不了，这样再去强行去分就达不到最佳的效果，所以我们允许部分数据分布在间隔的河道里，这就是软间隔，硬要分的话就是硬间隔 sklearn.svc 参数因为我们主要是使用分类模型，就只阐述SVC吧 sklearn中的SVC函数是基于libsvm实现的，所以在参数设置上有很多相似的地方。（PS: libsvm中的二次规划问题的解决算法是SMO）。LIBSVM是台湾大学林智仁(Lin Chih-Jen)教授等开发设计的一个简单、易于使用和快速有效的SVM模式识别与回归的软件包。有关SMO最后介绍 C: float参数 默认值为1.0 错误项的惩罚系数。C越大，即对分错样本的惩罚程度越大，因此在训练样本中准确率越高，但是泛化能力会降低。 kernel: 默认为‘rbf’ 核函数可选参数有： ‘linear’:线性核函数 ‘poly’：多项式核函数 ‘rbf’：径像核函数/高斯核 ‘sigmod’:sigmod核函数 ‘precomputed’:核矩阵 你也可以自定义核函数 degree: int型参数 默认为3 这个参数只对多项式核函数有用，是指多项式核函数的阶数n 如果给的核函数参数是其他核函数，则会自动忽略该参数。 gamma: float参数 默认为auto 核函数系数，只对‘rbf’,‘poly’,‘sigmod’有效。 如果gamma为auto，代表其值为样本特征数的倒数，即1/n_features. coef0: float参数 默认为0.0 核函数中的独立项，只有对‘poly’和‘sigmod’核函数有用，是指其中的参数c probability： bool参数 默认为False 是否启用概率估计。 这必须在调用fit()之前启用，并且会fit()方法速度变慢。 shrinking： bool参数 默认为True 是否采用启发式收缩方式 tol: float参数 默认为1e^-3 svm停止训练的误差精度 cache_size： float参数 默认为200 指定训练所需要的内存，以MB为单位，默认为200MB。 class_weight： 字典类型或者‘balance’字符串。默认为None 给每个类别分别设置不同的惩罚参数C，如果没有给，则会给所有类别都给C=1，即前面参数指出的参数C. 如果给定参数‘balance’，则使用y的值自动调整与输入数据中的类频率成反比的权重。 verbose ： bool参数 默认为False 是否启用详细输出。 此设置利用libsvm中的每个进程运行时设置，如果启用，可能无法在多线程上下文中正常工作。一般情况都设为False，不用管它。 max_iter ： int参数 默认为-1 最大迭代次数，如果为-1，表示不限制 random_state： int型参数 默认为None 属性有哪些：svc.n_support_：各类各有多少个支持向量 svc.support_：各类的支持向量在训练样本中的索引 svc.support_vectors_：各类所有的支持向量 为什么要用核函数？这里用到了一网图，获取链接：https://blog.csdn.net/SummerStoneS/article/details/78551757 如果你的数据在低维空间无法用低维手段分来，那么你可以将数据升维到高维空间用低维手段进行区分，这个核函数就是这个作用。那么为什么不用高维手段来分呢？因为高维表述复杂，我们习惯于用简单的算法来描述复杂现象。比如你说大多数鸟儿都会飞，远比你说除了生病，死亡，残疾，正在休息……的鸟儿都会飞来得轻松，低维表述虽然会损失部分精度，但是我觉得也不是不能接受 SMO的介绍要介绍SMO的话，还是得从SVM说起。 分类器的共同目标都是学一个平面正确分开正反例，就是： SVM引入了支持向量，就当作哪些难以区分的点来看待吧，那么点x到平面的距离就是： 假设超平面可以完全正确地将所有样本分类，则对于任意一个样本（xi，yi）来说都有如下性质： 两个类支持向量到超平面距离之和为： 最大化这个距离就是最小化它的倒数： 这是一个优化问题，可以使用拉格朗日乘子法求解其对偶问题，SVM的对偶问题表达： 由于采用了拉格朗日乘子法，因此该对偶问题还有一个KKT条件约束，即要求： SMO算法思想观察SVM的优化目标我们可以发现其最终的目的是要计算出一组最优的alpha和常数项b的值。SMO算法的中心思想就是每次选出两个alpha进行优化（之所以是两个是因为alpha的约束条件决定了其与标签乘积的累加等于0，因此必须一次同时优化两个，否则就会破坏约束条件），然后固定其他的alpha值。重复此过程，直到达到某个终止条件程序退出并得到我们需要的优化结果。 https://www.jianshu.com/p/eef51f939ace 算法数学推导由于SVM中有核函数的概念，因此我们用Kij来表示在核函数K下向量i和向量j的计算值。现在假定我们已经选出alpha1和alpha2两个待优化项，然后将原优化目标函数展开为与alpha1和alpha2有关的部分和无关的部分： 其中c是与alpha1和alpha2无关的部分，在本次优化中当做常数项处理。由SVM优化目标函数的约束条件： 可以得到： 将优化目标中所有的alpha1都替换为用alpha2表示的形式，得到如下式子： 此时，优化目标中仅含有alpha2一个待优化变量了，我们现在将待优化函数对alpha2求偏导得到如下结果： 已知： 将以上三个条件带入偏导式子中，得到如下结果： 化简后得： 记： 若n&lt;=0则退出本次优化，若n&gt;0则可得到alpha2的更新公式： 此时，我们已经得到了alpha2的更新公式。不过我们此时还需要考虑alpha2的取值范围问题。因为alpha2的取值范围应该是在0到C之间，但是在这里并不能简单地把取值范围限定在0至C之间，因为alpha2的取值不仅仅与其本身的范围有关，也与alpha1，y1和y2有关。设alpha1y1+alpha2y2=k，画出其约束，在这里要分两种情况，即y1是否等于y2。我们在这里先来考虑y1!=y2的情况：在这种情况下alpha1-alpha2=k： 可以看出此时alpha2的取值范围为： 当y1=y2时，alpha1+alpha2=k： 可以看出此时alpha2的取值范围为： 以上，可以总结出alpha2的取值上下界的规律： 故可得到alpha2的取值范围： 由alpha_old1y1+alpha_old2y2=alpha_new1y1+alpha_new2y2可得alpha1的更新公式： 接下来，需要确定常数b的更新公式，在这里首先需要根据“软间隔”下SVM优化目标函数的KKT条件推导出新的KKT条件，得到结果如下： 由于现在alpha的取值范围已经限定在0至C之间，也就是上面KKT条件的第三种情况。接下来我们将第三种KKT条件推广到任意核函数的情境下： 由此我们可以得到常数b的更新公式： 其中Ei是SVM的预测误差，计算式为： 接下来，我们可以根据这些推导对SMO算法进行实现，并且用我们的算法训练一个SVM分类器 抓住其中两个特别重要的点就行了： 如何选取每次迭代的alpha对 如何确定SVM优化程序的退出条件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165'''Created on 2018年3月28日@author: IL MARE代码源作者github:https://github.com/yhswjtuILMARE/Machine-Learning-Study-Notes/blob/master/SVM/Lib/SVMLib.py'''import numpy as npimport Lib.RFLib as RFLibdef kernalTransfrom(dataMatrix, vector, kTup): if kTup[0] == "lin": return vector * dataMatrix.transpose() elif kTup[0] == "rbf": delta = dataMatrix - vector K = np.matrix(np.diag(delta * delta.transpose()), dtype=np.float) K = np.exp(K / (-2 * kTup[1] ** 2)) return K else: raise NameError("Kernal Name Error")class osStruct: def __init__(self, dataMatIn, classlabels, C , toler, kTup): self.dataMatrix = np.matrix(dataMatIn, dtype=np.float) self.labelMatrix = np.matrix(classlabels, dtype=np.float).transpose() self.C = C self.toler = toler self.m = self.dataMatrix.shape[0] self.b = 0 self.alphas = np.matrix(np.zeros((self.m, 1)), dtype=np.float) self.eCache = np.matrix(np.zeros((self.m, 2)), dtype=np.float) self.K = np.matrix(np.zeros((self.m, self.m)), dtype=np.float) for i in range(self.m): self.K[i] = kernalTransfrom(self.dataMatrix, self.dataMatrix[i, :], kTup)def selectJRand(i, m): j = i while j == i: j = np.random.randint(0, m, 1)[0] return jdef clipAlpha(alpha, L, H): if alpha &gt;= H: return H elif alpha &lt;= L: return L else: return alphadef calEi(obj, i): fxi = float(np.multiply(obj.alphas, obj.labelMatrix).transpose() * \ obj.K[:, i]) + obj.b Ek = fxi - obj.labelMatrix[i, 0] return float(Ek)def updateEi(obj, i): Ei = calEi(obj, i) obj.eCache[i] = [1, Ei]def selectJIndex(obj, i, Ei): ''' 核心代码 ''' maxJ = -1 maxdelta = -1 Ek = -1 obj.eCache[i] = [1, Ei] vaildEiList = np.nonzero(obj.eCache[:, 0].A)[0] if len(vaildEiList) &gt; 1: for j in vaildEiList: if j == i: continue Ej = calEi(obj, j) delta = np.abs(Ei - Ej) if delta &gt; maxdelta: maxdelta = delta maxJ = j Ek = Ej else: maxJ = selectJRand(i, obj.m) Ek = calEi(obj, maxJ) return Ek, maxJdef innerLoop(obj, i): Ei = calEi(obj, i) if (obj.labelMatrix[i, 0] * Ei &lt; -obj.toler and obj.alphas[i, 0] &lt; obj.C) or \ (obj.labelMatrix[i, 0] * Ei &gt; obj.toler and obj.alphas[i, 0] &gt; 0): Ej, j = selectJIndex(obj, i, Ei) alphaIold = obj.alphas[i, 0].copy() alphaJold = obj.alphas[j, 0].copy() if obj.labelMatrix[i, 0] == obj.labelMatrix[j, 0]: L = max(0, obj.alphas[i, 0] + obj.alphas[j, 0] - obj.C) H = min(obj.C , obj.alphas[i, 0] + obj.alphas[j, 0]) else: L = max(0, obj.alphas[j, 0] - obj.alphas[i, 0]) H = min(obj.C, obj.C - obj.alphas[i, 0] + obj.alphas[j, 0]) if L == H: return 0 eta = obj.K[i, i] + obj.K[j, j] - 2 * obj.K[i, j] if eta &lt;= 0: return 0 obj.alphas[j, 0] += obj.labelMatrix[j, 0] * (Ei - Ej) / eta obj.alphas[j, 0] = clipAlpha(obj.alphas[j, 0], L, H) updateEi(obj, j) if np.abs(obj.alphas[j, 0] - alphaJold) &lt; 0.00001: return 0 obj.alphas[i, 0] += obj.labelMatrix[i, 0] * obj.labelMatrix[j, 0] * (alphaJold - obj.alphas[j, 0]) updateEi(obj, i) b1 = -Ei - obj.labelMatrix[i, 0] * obj.K[i, i] * (obj.alphas[i, 0] - alphaIold) \ - obj.labelMatrix[j, 0] * obj.K[i, j] * (obj.alphas[j, 0] - alphaJold) + obj.b b2 = -Ej - obj.labelMatrix[i, 0] * obj.K[i, j] * (obj.alphas[i, 0] - alphaIold) \ - obj.labelMatrix[j, 0] * obj.K[j, j] * (obj.alphas[j, 0] - alphaJold) + obj.b if obj.alphas[i, 0] &gt; 0 and obj.alphas[i, 0] &lt; obj.C: obj.b = b1 elif obj.alphas[j, 0] &gt; 0 and obj.alphas[j, 0] &lt; obj.C: obj.b = b2 else: obj.b = (b1 + b2) / 2.0 return 1 else: return 0def realSMO(trainSet, trainLabels, C, toler, kTup=('lin', 1.3), maxIter=40): ''' 核心代码 ''' obj = osStruct(trainSet, trainLabels, C, toler, kTup) entrySet = True iterNum = 0 alphapairschanged = 0 while (iterNum &lt; maxIter) and (alphapairschanged &gt; 0 or entrySet): print(iterNum) alphapairschanged = 0 if entrySet: for i in range(obj.m): alphapairschanged += innerLoop(obj, i) if i % 100 == 0: print("full set loop, iter: %d, alphapairschanged: %d, iterNum: %d" % (i, alphapairschanged, iterNum)) iterNum += 1 else: vaildalphsaList = np.nonzero((obj.alphas.A &gt; 0) * (obj.alphas.A &lt; C))[0] for i in vaildalphsaList: alphapairschanged += innerLoop(obj, i) if i % 100 == 0: print("non-bound set loop, iter: %d, alphapairschanged: %d, iterNum: %d" % (i, alphapairschanged, iterNum)) iterNum += 1 if entrySet: entrySet = False elif alphapairschanged == 0: entrySet = True print("iter num: %d" % (iterNum)) return obj.alphas, obj.bdef getSupportVectorandSupportLabel(trainSet, trainLabel, alphas): vaildalphaList = np.nonzero(alphas.A)[0] dataMatrix = np.matrix(trainSet, dtype=np.float) labelMatrix = np.matrix(trainLabel, dtype=np.float).transpose() sv = dataMatrix[vaildalphaList]#得到支持向量 svl = labelMatrix[vaildalphaList] return sv, svldef predictLabel(data, sv, svl, alphas, b, kTup): kernal = kernalTransfrom(sv, np.matrix(data, dtype=np.float), kTup).transpose() fxi = np.multiply(svl.T, alphas[alphas != 0]) * kernal + b return np.sign(float(fxi)) 最后，附上一张本人照片，以缓解学习头昏脑胀]]></content>
      <categories>
        <category>一些笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[直接可以用的Python和OpenCV检测及分割图像的目标区域例子]]></title>
    <url>%2Freading%2FOpenCV%E6%A3%80%E6%B5%8B%E5%88%86%E5%89%B2%E5%9B%BE%E5%83%8F.html</url>
    <content type="text"><![CDATA[直接可以用的Python和OpenCV检测及分割图像的目标区域例子第一天老师：你知道么，今天有人问了我一个问题。~.我：什么？老师：他说很难。~.我：关于什么的？老师：图像处理。~.我：喔，你说说看，我确实做了不少图像处理的东西（心里默念，你不知知道你给过我多少图像吗？）老师：好嘞！在用深度学习的时候，比如说面对一张图像，对某个区域感兴趣怎么办？~.我：他傻啊，切割出来啊，只需要训练感兴趣的部分就好啦。 老师：哎，那你给我一个教程，我正好顺手把他的问题解决了。~.我：好的（黑人脸.gif）老师：我回头把图片数据发给你。~.我：好的好的，老师，by the way, 有多少数据啊？老师：也不多，一个U盘够了，这样吧，明天你过来拷一下吧。~.我：好的（hello？一个U盘？） 第二天 有这么一个文件看了里面。。。我要爆炸了。。。 &gt; 598M * 15 = 8970M = 8.97G 我的个妈呀。 打开一看 全是密密麻麻的——虫子！！！为了视觉体验，自动屏蔽，请大家自行去谷歌：虫子、worm、bug、insects。。。 三天后~.我： 老师， 我就给一个方法啊， 不同的虫子他们可以自己调阈值和方法，我已经有写说明文件。老师： 好的，我看看。 考虑到视觉忍受能力，我用一个可爱的虫子做为一个示例，其他的都差不多，大家自行尝试。 目标是把虫子区域抠出来 环境：例图：谷歌，可爱的虫子–image软件：Anaconda 4.20，Opencv3.2OpenCv的安装：1.1安装Python3.601.2下载安装opencv3.2 具体思路如下：1.获取图片，这个简单哈123img_path = r'C:\Users\aixin\Desktop\chongzi.png'img = cv2.imread(img_path)gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) 看，这不就是你处理初始的样子？ 2.转换灰度并去噪声12gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)blurred = cv2.GaussianBlur(gray, (9, 9),0) 我们可以得到这两张图，第一张是灰度图，第二张是去噪之后的，另外说一下，去噪咱们有很多种方法，均值滤波器、高斯滤波器、中值滤波器、双边滤波器等。 这里取高斯是因为高斯去噪效果是最好的。 3.提取图像的梯度12345gradX = cv2.Sobel(gray, ddepth=cv2.CV_32F, dx=1, dy=0)gradY = cv2.Sobel(gray, ddepth=cv2.CV_32F, dx=0, dy=1)gradient = cv2.subtract(gradX, gradY)gradient = cv2.convertScaleAbs(gradient) 以Sobel算子计算x，y方向上的梯度，之后在x方向上减去y方向上的梯度，通过这个减法，我们留下具有高水平梯度和低垂直梯度的图像区域。 此时，我们会得到 4.我们继续去噪声 考虑到图像的孔隙 首先使用低通滤泼器平滑图像, 这将有助于平滑图像中的高频噪声。 低通滤波器的目标是降低图像的变化率。如将每个像素替换为该像素周围像素的均值， 这样就可以平滑并替代那些强度变化明显的区域。 对模糊图像二值化，顾名思义，就是把图像数值以某一边界分成两种数值，细节我会附在文章底部，如果还是不懂，去cao文档吧。 12blurred = cv2.GaussianBlur(gradient, (9, 9),0)(_, thresh) = cv2.threshold(blurred, 90, 255, cv2.THRESH_BINARY) 此时，我们会得到 其实就算手动分割我们也是需要找到一个边界吧，可以看到轮廓出来了，但是我们最终要的是整个轮廓，所以内部小区域就不要了 5.图像形态学（牛逼吧、唬人的）在这里我们选取ELLIPSE核，采用CLOSE操作，具体细节你依旧可以参考我的附录文档，及拓展。 12kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (25, 25))closed = cv2.morphologyEx(thresh, cv2.MORPH_CLOSE, kernel) 此时，我们会得到 6.细节刻画从上图我们可以发现和原图对比，发现有细节丢失，这会干扰之后的昆虫轮廓的检测，要把它们扩充，分别执行4次形态学腐蚀与膨胀（附录文档） 12closed = cv2.erode(closed, None, iterations=4)closed = cv2.dilate(closed, None, iterations=4) 此时，我们会得到 7.找出昆虫区域的轮廓此时用cv2.findContours()函数第一个参数是要检索的图片，必须是为二值图，即黑白的（不是灰度图） 1234567891011121314(_, cnts, _) = cv2.findContours( 参数一： 二值化图像 closed.copy(), 参数二：轮廓类型 # cv2.RETR_EXTERNAL, #表示只检测外轮廓 # cv2.RETR_CCOMP, #建立两个等级的轮廓,上一层是边界 # cv2.RETR_LIST, #检测的轮廓不建立等级关系 # cv2.RETR_TREE, #建立一个等级树结构的轮廓 # cv2.CHAIN_APPROX_NONE, #存储所有的轮廓点，相邻的两个点的像素位置差不超过1 参数三：处理近似方法 # cv2.CHAIN_APPROX_SIMPLE, #例如一个矩形轮廓只需4个点来保存轮廓信息 # cv2.CHAIN_APPROX_TC89_L1, # cv2.CHAIN_APPROX_TC89_KCOS ) 8.画出轮廓找到轮廓了，接下来，要画出来的，即用cv2.drawContours()函数。 123456789c = sorted(cnts, key=cv2.contourArea, reverse=True)[0]# compute the rotated bounding box of the largest contourrect = cv2.minAreaRect(c)box = np.int0(cv2.boxPoints(rect))# draw a bounding box arounded the detected barcode and display the imagedraw_img = cv2.drawContours(img.copy(), [box], -1, (0, 0, 255), 3)cv2.imshow("draw_img", draw_img) 此时，我们会得到 9.裁剪出来就完成啦方法嘛，这不就是么，找到这四个点切出来就好啦我们放大一点看一下细节 12345678910Xs = [i[0] for i in box]Ys = [i[1] for i in box]x1 = min(Xs)x2 = max(Xs)y1 = min(Ys)y2 = max(Ys)hight = y2 - y1width = x2 - x1crop_img= img[y1:y1+hight, x1:x1+width]cv2.imshow('crop_img', crop_img) 其实，box里保存的是绿色矩形区域四个顶点的坐标。 我将按下图红色矩形所示裁剪昆虫图像。找出四个顶点的x，y坐标的最大最小值。新图像的高=maxY-minY，宽=maxX-minX 终于我们得到了可爱的小虫子。得到了目标区域，那么你想拿它干什么就干什么！我不管你哈。 考虑到现在的python教程一般都是一上来就是list、tuple什么的，而不是文件的读写和保存，包括批量读取等等，我特地加入了python版的文件批量读写和保存等附录文件。 快快快、夸我！ 附录1.实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#-*- coding: UTF-8 -*- '''Author: Steve WangTime: 2017/12/8 10:00Environment: Python 3.6.2 |Anaconda 4.3.30 custom (64-bit) Opencv 3.3'''import cv2import numpy as npdef get_image(path): #获取图片 img=cv2.imread(path) gray=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY) return img, gray def Gaussian_Blur(gray): # 高斯去噪 blurred = cv2.GaussianBlur(gray, (9, 9),0) return blurred def Sobel_gradient(blurred): # 索比尔算子来计算x、y方向梯度 gradX = cv2.Sobel(blurred, ddepth=cv2.CV_32F, dx=1, dy=0) gradY = cv2.Sobel(blurred, ddepth=cv2.CV_32F, dx=0, dy=1) gradient = cv2.subtract(gradX, gradY) gradient = cv2.convertScaleAbs(gradient) return gradX, gradY, gradientdef Thresh_and_blur(gradient): blurred = cv2.GaussianBlur(gradient, (9, 9),0) (_, thresh) = cv2.threshold(blurred, 90, 255, cv2.THRESH_BINARY) return thresh def image_morphology(thresh): # 建立一个椭圆核函数 kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (25, 25)) # 执行图像形态学, 细节直接查文档，很简单 closed = cv2.morphologyEx(thresh, cv2.MORPH_CLOSE, kernel) closed = cv2.erode(closed, None, iterations=4) closed = cv2.dilate(closed, None, iterations=4) return closed def findcnts_and_box_point(closed): # 这里opencv3返回的是三个参数 (_, cnts, _) = cv2.findContours(closed.copy(), cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE) c = sorted(cnts, key=cv2.contourArea, reverse=True)[0] # compute the rotated bounding box of the largest contour rect = cv2.minAreaRect(c) box = np.int0(cv2.boxPoints(rect)) return boxdef drawcnts_and_cut(original_img, box): # 因为这个函数有极强的破坏性，所有需要在img.copy()上画 # draw a bounding box arounded the detected barcode and display the image draw_img = cv2.drawContours(original_img.copy(), [box], -1, (0, 0, 255), 3) Xs = [i[0] for i in box] Ys = [i[1] for i in box] x1 = min(Xs) x2 = max(Xs) y1 = min(Ys) y2 = max(Ys) hight = y2 - y1 width = x2 - x1 crop_img = original_img[y1:y1+hight, x1:x1+width] return draw_img, crop_img def walk(): img_path = r'C:\Users\aixin\Desktop\chongzi.png' save_path = r'C:\Users\aixin\Desktop\chongzi_save.png' original_img, gray = get_image(img_path) blurred = Gaussian_Blur(gray) gradX, gradY, gradient = Sobel_gradient(blurred) thresh = Thresh_and_blur(gradient) closed = image_morphology(thresh) box = findcnts_and_box_point(closed) draw_img, crop_img = drawcnts_and_cut(original_img,box) # 暴力一点，把它们都显示出来看看 cv2.imshow('original_img', original_img) cv2.imshow('blurred', blurred) cv2.imshow('gradX', gradX) cv2.imshow('gradY', gradY) cv2.imshow('final', gradient) cv2.imshow('thresh', thresh) cv2.imshow('closed', closed) cv2.imshow('draw_img', draw_img) cv2.imshow('crop_img', crop_img) cv2.waitKey(20171219) cv2.imwrite(save_path, crop_img)walk() 附录2.本篇文章精华函数说明1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677# 用来转化图像格式的img = cv2.cvtColor(src, COLOR_BGR2HSV # BGR----&gt;HSV COLOR_HSV2BGR # HSV----&gt;BGR ...)# For HSV, Hue range is [0,179], Saturation range is [0,255] and Value range is [0,255]# 返回一个阈值，和二值化图像，第一个阈值是用来otsu方法时候用的# 不过现在不用了，因为可以通过mahotas直接实现T = ret = mahotas.threshold(blurred)ret, thresh_img = cv2.threshold(src, # 一般是灰度图像 num1, # 图像阈值 num2, # 如果大于或者num1, 像素值将会变成 num2# 最后一个二值化参数 cv2.THRESH_BINARY # 将大于阈值的灰度值设为最大灰度值，小于阈值的值设为0 cv2.THRESH_BINARY_INV # 将大于阈值的灰度值设为0，大于阈值的值设为最大灰度值 cv2.THRESH_TRUNC # 将大于阈值的灰度值设为阈值，小于阈值的值保持不变 cv2.THRESH_TOZERO # 将小于阈值的灰度值设为0，大于阈值的值保持不变 cv2.THRESH_TOZERO_INV # 将大于阈值的灰度值设为0，小于阈值的值保持不变)thresh = cv2.AdaptiveThreshold(src, dst, maxValue, # adaptive_method ADAPTIVE_THRESH_MEAN_C, ADAPTIVE_THRESH_GAUSSIAN_C, # thresholdType THRESH_BINARY, THRESH_BINARY_INV, blockSize=3, param1=5)# 一般是在黑色背景中找白色物体，所以原始图像背景最好是黑色# 在执行找边缘的时候，一般是threshold 或者是canny 边缘检测后进行的。# warning:此函数会修改原始图像、# 返回：坐标位置（x,y）, (_, cnts, _) = cv2.findContours(mask.copy(), # cv2.RETR_EXTERNAL, #表示只检测外轮廓 # cv2.RETR_CCOMP, #建立两个等级的轮廓,上一层是边界 cv2.RETR_LIST, #检测的轮廓不建立等级关系 # cv2.RETR_TREE, #建立一个等级树结构的轮廓 # cv2.CHAIN_APPROX_NONE, #存储所有的轮廓点，相邻的两个点的像素位置差不超过1 cv2.CHAIN_APPROX_SIMPLE, #例如一个矩形轮廓只需4个点来保存轮廓信息 # cv2.CHAIN_APPROX_TC89_L1, # cv2.CHAIN_APPROX_TC89_KCOS )img = cv2.drawContours(src, cnts, whichToDraw(-1), color, line)img = cv2.imwrite(filename, dst, # 文件路径，和目标图像文件矩阵 # 对于JPEG，其表示的是图像的质量，用0-100的整数表示，默认为95 # 注意，cv2.IMWRITE_JPEG_QUALITY类型为Long，必须转换成int [int(cv2.IMWRITE_JPEG_QUALITY), 5] [int(cv2.IMWRITE_JPEG_QUALITY), 95] # 从0到9,压缩级别越高，图像尺寸越小。默认级别为3 [int(cv2.IMWRITE_PNG_COMPRESSION), 5]) [int(cv2.IMWRITE_PNG_COMPRESSION), 9])# 如果你不知道用哪个flags，毕竟太多了哪能全记住，直接找找。寻找某个函数或者变量events = [i for i in dir(cv2) if 'PNG' in i]print( events )寻找某个变量开头的flagsflags = [i for i in dir(cv2) if i.startswith('COLOR_')]print flags批量读取文件名字import osfilename_rgb = r'C:\Users\aixin\Desktop\all_my_learning\colony\20170629'for filename in os.listdir(filename_rgb): #listdir的参数是文件夹的路径 print (filename) ————————————————版权声明：本文为CSDN博主「BRUCE_WUANG」的原创文章，遵循CC 4.0 by-sa版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/sinat_36458870/article/details/78825571 感谢博主分享，由于我的OpenCV版本不一样，所以有部分修改，附上我的代码如下： 1234567891011121314151617import cv2cv2.__version__Out[]: '4.1.0' def findcnts_and_box_point(closed): ''' 注意：这里opencv4.1.0 返回的是两个个参数 ''' (cnts, _) = cv2.findContours(closed.copy(), cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE) c = sorted(cnts, key=cv2.contourArea, reverse=True)[0] # compute the rotated bounding box of the largest contour rect = cv2.minAreaRect(c) box = np.int0(cv2.boxPoints(rect)) return box 源文档说明： 12345678§ findContours() [1/2]void cv::findContours ( InputArray image,OutputArrayOfArrays contours,OutputArray hierarchy,int mode,int method,Point offset = Point() ) 1contours, hierarchy = cv.findContours(image, mode, method[, contours[, hierarchy[, offset]]])]]></content>
      <categories>
        <category>一些笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[几种经典的卷积神经网络模型]]></title>
    <url>%2Freading%2F%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.html</url>
    <content type="text"><![CDATA[几种经典的卷积神经网络模型1.卷积神经网络介绍卷积神经网络（Convolutional Neural Networks, CNN）是一类包含卷积计算且具有深度结构的前馈神经网络（Feedforward Neural Networks），是深度学习（deep learning）的代表算法之一1.1输入层 输入层可以处理多维数据 1.2隐含层卷积神经网络的隐含层包含卷积层、池化层和全连接层3类常见构筑，在一些更为现代的算法中可能有Inception模块、残差块（residual block）等复杂构筑。 1.2.1 卷积层（convolutional layer）卷积核（convolutional kernel）:卷积层的功能是对输入数据进行特征提取，其内部包含多个卷积核，组成卷积核的每个元素都对应一个权重系数和一个偏差量（bias vector），类似于一个前馈神经网络的神经元（neuron）卷积层内每个神经元都与前一层中位置接近的区域的多个神经元相连，区域的大小取决于卷积核的大小，在文献中被称为“感受野（receptive field） 卷积层参数:卷积核大小、步长和填充，三者共同决定了卷积层输出特征图的尺寸，是卷积神经网络的超参数 激励函数（activation function）:ReLU出现以前，Sigmoid函数和双曲正切函数，在一些早期的卷积神经网络研究，例如LeNet-5中，激励函数在池化层之后 1.2.2池化层（pooling layer）：在卷积层进行特征提取后，输出的特征图会被传递至池化层进行特征选择和信息过滤 Inception模块（Inception module）：是对多个卷积层和池化层进行堆叠所得的隐含层构筑，具体而言，一个Inception模块会同时包含多个不同类型的卷积和池化操作，并使用相同填充使上述操作得到相同尺寸的特征图，随后在数组中将这些特征图的通道进行叠加并通过激励函数 1.2.3全连接层（fully-connected layer）：全连接层位于卷积神经网络隐含层的最后部分，并只向其它全连接层传递信号。特征图在全连接层中会失去空间拓扑结构，被展开为向量并通过激励函数，全连接层本身不被期望具有特征提取能力，而是试图利用现有的高阶特征完成学习目标。 1.3输出层： 输出层使用逻辑函数或归一化指数函数（softmax function）输出分类标签 在物体识别（object detection）问题中，输出层可设计为输出物体的中心坐标、大小和分类 在图像语义分割中，输出层直接输出每个像素的分类结果 2.卷积神经网络要解决什么图像数据本身具有特殊性，像素点之间是有关联的，如果直接展开进行学习分类，不但失去了形状空间的信息，像素点过多造成要学习的参数过多，几乎不可能完成训练。 卷积操作尝试去解决这个问题： 卷积层保留输⼊形状，使图像的像素在⾼和宽两个方向上的相关性均可能被有效识别 卷积层通过滑动窗口将同⼀卷积核与不同位置的输⼊重复计算，从而避免参数尺⼨过大。 卷积操作的优势： 稀疏连接 权值共享 怎么去理解，稀疏连接就像是军营等级制度，每一层只负责管理下面几个人，并只向上几个汇报，权值共享就是一个工厂生产，图纸大家一起使用，大大减少了每个人都要画一张的繁重 3.经典的卷积神经网络3.1 LeNet 卷积层块中，每个卷积层都使⽤5 × 5的窗口，并在输出上使⽤sigmoid激活函数。第⼀个卷积层输出通道数为6，第⼆个卷积层输出通道数则增加到16 3.2 AlexNetAlexNet使⽤了8层卷积神经⽹络，并以很⼤的优势赢得了ImageNet 2012图像识别挑战赛 AlexNet与LeNet的设计理念⾮常相似，但也有显著的区别。 第⼀，与相对较小的LeNet相⽐，AlexNet包含8层变换，其中有5层卷积和2层全连接隐藏层，以及1个全连接输出层。下⾯我们来详细描述这些层的设计。AlexNet第⼀层中的卷积窗口形状是11 × 11。因为ImageNet中绝⼤多数图像的⾼和宽均⽐MNIST图像的⾼和宽⼤10倍以上，ImageNet图像的物体占⽤更多的像素，所以需要更⼤的卷积窗口来捕获物体。第⼆层中的卷积窗口形状减小到5 × 5，之后全采⽤3 × 3。此外，第⼀、第⼆和第五个卷积层之后都使⽤了窗口形状为3 × 3、步幅为2的最⼤池化层。而且，AlexNet使⽤的卷积通道数也⼤于LeNet中的卷积通道数数⼗倍。紧接着最后⼀个卷积层的是两个输出个数为4096的全连接层。这两个巨⼤的全连接层带来将近1GB的模型参数。由于早期显存的限制，最早的AlexNet使⽤双数据流的设计使⼀个GPU只需要处理⼀半模型。幸运的是，显存在过去⼏年得到了长足的发展，因此通常我们不再需要这样的特别设计了。 第⼆，AlexNet将sigmoid激活函数改成了更加简单的ReLU激活函数。⼀⽅⾯，ReLU激活函数的计算更简单，例如它并没有sigmoid激活函数中的求幂运算。另⼀⽅⾯，ReLU激活函数在不同的参数初始化⽅法下使模型更容易训练。这是由于当sigmoid激活函数输出极接近0或1时，这些区域的梯度⼏乎为0，从而造成反向传播⽆法继续更新部分模型参数；而ReLU激活函数在正区间的梯度恒为1。因此，若模型参数初始化不当，sigmoid函数可能在正区间得到⼏乎为0的梯度，从而令模型⽆法得到有效训练。 第三，AlexNet通过丢弃法来控制全连接层的模型复杂度。而LeNet并没有使⽤丢弃法。 第四，AlexNet引⼊了⼤量的图像增⼴，如翻转、裁剪和颜⾊变化，从而进⼀步扩⼤数据集来缓解过拟合。 3.3 VGG3.3.1 VGG块VGG块的组成规律是：连续使⽤数个相同的填充为1、窗口形状为3 × 3的卷积层后接上⼀个步幅为2、窗口形状为2 × 2的最⼤池化层。卷积层保持输⼊的⾼和宽不变，而池化层则对其减半。 3.3.2 VGG网络 与AlexNet和LeNet⼀样，VGG⽹络由卷积层模块后接全连接层模块构成。卷积层模块串联数个vgg_block，其超参数由变量conv_arch定义。该变量指定了每个VGG块⾥卷积层个数和输出通道数。全连接模块则跟AlexNet中的⼀样。现在我们构造⼀个VGG⽹络。它有5个卷积块，前2块使⽤单卷积层，而后3块使⽤双卷积层。第⼀块的输出通道是64，之后每次对输出通道数翻倍，直到变为512。因为这个⽹络使⽤了8个卷积层和3个全连接层，所以经常被称为VGG-11。 其实是从VGG开始，大家发现，与其使用更多卷积核，更大的网络，不如使用小卷积核更深的网络来替代。也就是说这时候解决梯度消失和梯度爆炸成为一个必须面对的问题 3.4 NiN3.4.1 Nin块我们知道， 卷积层的输⼊和输出通常是四维数组 （样本， 通道， ⾼， 宽） ， 而全连接层的输⼊和输出则通常是⼆维数组 （样本， 特征） 。 如果想在全连接层后再接上卷积层， 则需要将全连接层的输出变换为四维。 回忆在 “多输⼊通道和多输出通道” ⼀节⾥介绍的1×1卷积层。 它可以看成全连接层， 其中空间维度 （⾼和宽） 上的每个元素相当于样本， 通道相当于特征。 因此， NiN使⽤1×1卷积层来替代全连接层， 从而使空间信息能够⾃然传递到后⾯的层中去。 下图对⽐了NiN同AlexNet和VGG等⽹络在结构上的主要区别。 3.4.2 Nin网络 除使⽤NiN块以外，NiN还有⼀个设计与AlexNet显著不同：NiN去掉了AlexNet最后的3个全连接层，取而代之地，NiN使⽤了输出通道数等于标签类别数的NiN块，然后使⽤全局平均池化层对每个通道中所有元素求平均并直接⽤于分类。 这⾥的全局平均池化层即窗口形状等于输⼊空间维形状的平均池化层。NiN的这个设计的好处是可以显著减小模型参数尺⼨，从而缓解过拟合。然而，该设计有时会造成获得有效模型的训练时间的增加。 3.5 GooLeNet名字就能看出来，是向LeNet致敬 3.5.1 Inception块 Inception块⾥有4条并⾏的线路。前3条线路使⽤窗口⼤小分别是1 × 1、3 ×3和5 × 5的卷积层来抽取不同空间尺⼨下的信息，其中中间2个线路会对输⼊先做1 × 1卷积来减少输⼊通道数，以降低模型复杂度。第四条线路则使⽤3 × 3最⼤池化层，后接1 × 1卷积层来改变通道数。4条线路都使⽤了合适的填充来使输⼊与输出的⾼和宽⼀致。最后我们将每条线路的输出在通道维上连结，并输⼊接下来的层中去。 3.5.2 GoogLeNet网络GoogLeNet跟VGG⼀样， 在主体卷积部分中使⽤5个模块 （block） ， 每个模块之间使⽤步幅为2的3×3最⼤池化层来减小输出⾼宽。 第⼀模块使⽤⼀个64通道的7 × 7卷积层。 第⼆模块使⽤2个卷积层：⾸先是64通道的1 × 1卷积层， 然后是将通道增⼤3倍的3 × 3卷积层。它对应Inception块中的第⼆条线路。 第三模块串联2个完整的Inception块。 第⼀个Inception块的输出通道数为64+128+32+32 = 256，其中4条线路的输出通道数⽐例为64 : 128 : 32 : 32 = 2 : 4 : 1 : 1。 其中第⼆、 第三条线路先分别将输⼊通道数减小⾄96/192 = 1/2和16/192 = 1/12后，再接上第⼆层卷积层。第⼆个Inception块输出通道数增⾄128 + 192 + 96 + 64 = 480，每条线路的输出通道数之⽐为128 : 192 : 96 : 64 =4 : 6 : 3 : 2。其中第⼆、第三条线路先分别将输⼊通道数减小⾄128/256 = 1/2和32/256 = 1/8。 第四模块更加复杂。它串联了5个Inception块，其输出通道数分别是192 + 208 + 48 + 64 = 512、160+224+64+64 = 512、128+256+64+64 = 512、 112+288+64+64 = 528和256+320+128+128 =832。这些线路的通道数分配和第三模块中的类似，⾸先含3 × 3卷积层的第⼆条线路输出最多通道， 其次是仅含1 × 1卷积层的第⼀条线路， 之后是含5 × 5卷积层的第三条线路和含3 × 3最⼤池化层的第四条线路。 其中第⼆、 第三条线路都会先按⽐例减小通道数。 这些⽐例在各个Inception块中都略有不同。 第五模块有输出通道数为256 + 320 + 128 + 128 = 832和384 + 384 + 128 + 128 = 1024的两个Inception块。 其中每条线路的通道数的分配思路和第三、 第四模块中的⼀致， 只是在具体数值上有所不同。需要注意的是，第五模块的后⾯紧跟输出层，该模块同NiN⼀样使⽤全局平均池化层来将每个通道的⾼和宽变成1。最后我们将输出变成⼆维数组后接上⼀个输出个数为标签类别数的全连接层。GoogLeNet模型的计算复杂，而且不如VGG那样便于修改通道数。 3.6 ResNet理论上，原模型解的空间只是新模型解的空间的⼦空间。也就是说，如果我们能将新添加的层训练成恒等映射f(x) = x，新模型和原模型将同样有效。由于新模型可能得出更优的解来拟合训练数据集，因此添加层似乎更容易降低训练误差。然而在实践中，添加过多的层后训练误差往往不降反升。即使利⽤批量归⼀化带来的数值稳定性使训练深层模型更加容易，该问题仍然存在。 针对这⼀问题， 何恺明等⼈提出了残差⽹络（ResNet）。 它在2015年的ImageNet图像识别挑战赛夺魁，并深刻影响了后来的深度神经⽹络的设计。 3.6.1 残差块让我们聚焦于神经⽹络局部。如图所⽰，设输⼊为x。假设我们希望学出的理想映射为f(x)，从而作为图上⽅激活函数的输⼊。左图虚线框中的部分需要直接拟合出该映射f(x)，而右图虚线框中的部分则需要拟合出有关恒等映射的残差映射f(x) − x。残差映射在实际中往往更容易优化。以本节开头提到的恒等映射作为我们希望学出的理想映射f(x)。我们只需将图中右图虚线框内上⽅的加权运算（如仿射）的权重和偏差参数学成0，那么f(x)即为恒等映射。实际中，当理想映射f(x)极接近于恒等映射时，残差映射也易于捕捉恒等映射的细微波动。右图也是ResNet的基础块，即残差块（residual block） 。在残差块中，输⼊可通过跨层的数据线路更快地向前传播。 3.6.2 残差网络 ResNet沿⽤了VGG全3 × 3卷积层的设计。残差块⾥⾸先有2个有相同输出通道数的3 × 3卷积层。每个卷积层后接⼀个批量归⼀化层和ReLU激活函数。然后我们将输⼊跳过这两个卷积运算后直接加在最后的ReLU激活函数前。这样的设计要求两个卷积层的输出与输⼊形状⼀样，从而可以相加。如果想改变通道数， 就需要引⼊⼀个额外的1 × 1卷积层来将输⼊变换成需要的形状后再做相加运算。 3.7 DenseNetResNet中的跨层连接设计引申出了数个后续⼯作。本节我们介绍其中的⼀个：稠密连接⽹络（DenseNet）。它与ResNet的主要区别如图所⽰。 图中将部分前后相邻的运算抽象为模块A和模块B。与ResNet的主要区别在于，DenseNet⾥模块B的输出不是像ResNet那样和模块A的输出相加，而是在通道维上连结。这样模块A的输出可以直接传⼊模块B后⾯的层。在这个设计⾥，模块A直接跟模块B后⾯的所有层连接在了⼀起。这也是它被称为“稠密连接”的原因。 DenseNet的主要构建模块是稠密块（dense block）和过渡层（transition layer） 。前者定义了输⼊和输出是如何连结的，后者则⽤来控制通道数，使之不过⼤。 参考博客：https://blog.csdn.net/yaoxunji/article/details/88351396 文中简单介绍了主流卷积网络，接下来我会分两部分对作者的这篇博客进行补充，一是把论文进行翻译解读，二是用不同的框架对论文网络进行复现]]></content>
      <categories>
        <category>一些笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[7.Python的随机数模块]]></title>
    <url>%2Fpython%2F7.Python%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%A8%A1%E5%9D%97.html</url>
    <content type="text"><![CDATA[书接上文随机数可以用于数学，游戏，安全等领域中，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性。Python随机数函数 函数 描述 choice(seq) 从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。 randrange ([start,] stop [,step]) 从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1 random() 随机生成下一个实数，它在[0,1)范围内。 [seed(x)] 改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。 shuffle(lst) 将序列的所有元素随机排序 uniform(x, y) 随机生成下一个实数，它在[x,y]范围内。 sample 序列中取出指定个数 123456789101112131415&gt;&gt;&gt; import random&gt;&gt;&gt; random.choice(range(10))0&gt;&gt;&gt; random.randrange(1,10,3)1&gt;&gt;&gt; random.random()0.023248875506237332&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; random.shuffle(a)&gt;&gt;&gt; a[2, 1, 3]&gt;&gt;&gt; random.uniform(1,10)3.86057585107958&gt;&gt;&gt; random.sample(range(10),k=3)[4, 9, 3] 利用随机数模块还可以进行概率分布的模拟，可以用在其他数值分析领域，例如金融，包括机器学习的初始化 本来想深入的，但是实际上用到这个模块也就上面的这些，我个人用的较多的是：choice , random , shuffle —欲知后事如何，且听下回分解]]></content>
      <categories>
        <category>Python 教程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数值类型作业]]></title>
    <url>%2Fhomework%2Fnumber.html</url>
    <content type="text"><![CDATA[1.把你的名字拼音用编码数字进行输出12345678&gt;&gt;&gt; name = 'chen'&gt;&gt;&gt; a = ord(name[0])&gt;&gt;&gt; b = ord(name[1])&gt;&gt;&gt; c = ord(name[2])&gt;&gt;&gt; d = ord(name[3])&gt;&gt;&gt; s = str(a) + str(b) + str(c) + str(d)&gt;&gt;&gt; s'99104101110' 2.把上一题的编码解析出来，你或许以后可以用这个当成你的某网站密码 1234567&gt;&gt;&gt; a1 = chr(a)&gt;&gt;&gt; b1 = chr(b)&gt;&gt;&gt; c1 = chr(c)&gt;&gt;&gt; d1 = chr(d)&gt;&gt;&gt; yourname = a1 + b1 + c1 + d1&gt;&gt;&gt; yourname'chen' 3.数字3.1向上取整 123&gt;&gt;&gt; import math&gt;&gt;&gt; math.ceil(3.1)4 4.数字4.9向下取整 12&gt;&gt;&gt; math.floor(4.9)4 5.数字5.555保留两位小数 12&gt;&gt;&gt; round(5.555,2)5.55 6.把你名字的数字编码转为二进制，八进制，十六进制 123456789&gt;&gt;&gt; binname = bin(a) + bin(b) + bin(c) + bin(d)&gt;&gt;&gt; octname = oct(a) + oct(b) + oct(c) + oct(d)&gt;&gt;&gt; hexname = hex(a) + hex(b) + hex(c) + hex(d)&gt;&gt;&gt; binname'0b11000110b11010000b11001010b1101110'&gt;&gt;&gt; octname'0o1430o1500o1450o156'&gt;&gt;&gt; hexname'0x630x680x650x6e' 7.将数字8.88转为整型 12&gt;&gt;&gt; int(8.88)8 8.将字符串的python语句转为正常语句，再赋给一个字符串 12345&gt;&gt;&gt; eval(s)414&gt;&gt;&gt; s1 = repr(a + b + c + d)&gt;&gt;&gt; s1'414']]></content>
      <categories>
        <category>作业</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[5.Python的数字类型]]></title>
    <url>%2Fpython%2F5.Python%E7%9A%84%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B.html</url>
    <content type="text"><![CDATA[书接上文上一篇博客中简单介绍了一下Python的各种变量类型，这一篇我们重点介绍Python的数字类型。数字类型算得上是程序语言的灵魂了，大家都知道计算机通过高低电平的状态，规定高电平为1，低电平为0，用0和1来表示了如此庞大的计算体系。用0和1推演出字符，数字等的表达方式，再用数字，字符组成了如此复杂的程序结构。古老的程序员都是用打孔纸带进行编程，哪有现在这么舒服。作为语言中最重要的一环，数字，不得不首先介绍它，因为没有数字就真的什么都没有了。包括没有在数学的表达上也是0，所以这么世界就是数学，没有数学表达不了的东西。 下面，我们就正式进入数值类型的学习，银行卡余额的数字大家应该还是很关心的。 Python Number(数字)Python Number 数据类型用于存储数值。 数据类型是不允许改变的,这就意味着如果改变 Number 数据类型的值，将重新分配内存空间。 Python 支持三种不同的数值类型： 整型(Int) - 通常被称为是整型或整数，是正或负整数，不带小数点。 浮点型(floating point real values) - 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 = 2.5 x 10^2 = 250） 复数(complex numbers) - 复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。 Python Number 类型转换 语法 解释 int(x [,base ]) 将x转换为一个整数 float(x) 将x转换到一个浮点数 complex(real [,imag ]) 创建一个复数 str(x) 将对象 x 转换为字符串 repr(x) 将对象 x 转换为表达式字符串 eval(str) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s) 将序列 s 转换为一个元组 list(s) 将序列 s 转换为一个列表 chr(x) 将一个整数转换为一个字符 unichr(x) 将一个整数转换为Unicode字符 ord(x) 将一个字符转换为它的整数值 hex(x) 将一个整数转换为一个十六进制字符串 oct(x) 将一个整数转换为一个八进制字符串 bin(x) 将一个整数转换为一个二进制字符串 我们选讲 repr , eval , chr , ord , hex , oct , bin123a = b = 1c = repr(a+b)d = str(a + b) 12c , type(c)d , type(d) 12('2', str) ('2', str) a + b 是一个表达式，使用 repr 将其转化为了字符串格式，当然也可以使用 str 进行转换。两者有什么区别呢？ repr和str这两个方法都是用于显示的，str是面向用户的，而repr面向程序员。 打印操作会首先尝试str和str内置函数(print运行的内部等价形式)，它通常应该返回一个友好的显示。 repr用于所有其他的环境中：用于交互模式下提示回应以及repr函数，如果没有使用str，会使用print和str。它通常应该返回一个编码字符串，可以用来重新创建对象，或者给开发者详细的显示。 当我们想所有环境下都统一显示的话，可以重构repr方法；当我们想在不同环境下支持不同的显示，例如终端用户显示使用str，而程序员在开发期间则使用底层的repr来显示，实际上str只是覆盖了repr以得到更友好的用户显示。 大概了解一下，不懂没关系。等学完整个课程再来理解就好。 下面的示例为未来王者归来的你所写，提前面个眼缘就行。 12345678910# -*- coding: utf-8 -*-class Test(object): def __init__(self,value='hello world'): self.data = valuet = Test()print(t)&lt;__main__.Test object at 0x00000249BD7180F0&gt; 上面打印类对象并不是很友好，显示的是对象的内存地址 下面我们重构下该类的repr以及str，看看它们俩有啥区别 12345678910111213141516171819202122# -*- coding: utf-8 -*-class Test(object): def __init__(self,value='hello world'): self.data = valuet = Test()print(t)class Test_Repr(Test): def __repr__(self): return 'Repr:&#123;&#125;'.format(self.data) class Test_Str(Test): def __str__(self): return 'Str:&#123;&#125;'.format(self.data)tr = Test_Repr()print(tr)ts = Test_Str()print(ts) 1234567891011121314&lt;__main__.Test object at 0x00000249BD718BA8&gt;Repr:hello worldStr:hello world#似乎后面两个还是一样的？#这里就要用交互环境了In[]:tOut[]: &lt;__main__.Test at 0x249bd718ba8&gt;In[]:trOut[]: Repr:hello worldIn[]:tsOut[10]: &lt;__main__.Test_Str at 0x249bd718860&gt; 相信你一定很好奇后面那一长串的16进制数是什么玩意，它就是变量的存储在内存中的内存地址，查看任何变量的内存地址都可以使用 id 来看 123456id(t)Out[11]: 2515734203304ps：好像是十进制和上面显示的不一样呃，还记得用什么转16进制吗？ 既然这里用到了，那就不说了hex(id(t))Out[12]: '0x249bd718ba8' eval 将字符串转为Python表达式并返回结果假如你要根据你每月的消费情况统计每个月的平均花费，你已经统计好了每个月的消费金额，刚好你计算机上的计算器无法使用，让室友帮你，结果他只给了你一个计算的字符串。编不下去了，直接开始 1234567891011a = 100b = 200s = '(a + b) / 2 ' c = eval(s)print(c)print(type(c))150.0&lt;class 'float'&gt; chr 和 ord12345678910111213141516&gt;&gt;&gt; ord('a')97&gt;&gt;&gt; ord('b')98&gt;&gt;&gt; ord('A')65&gt;&gt;&gt; ord('B')66&gt;&gt;&gt; chr(97)'a'&gt;&gt;&gt; chr(98)'b'&gt;&gt;&gt; chr(65)'A'&gt;&gt;&gt; chr(66)'B' 发现规律了吗，这两个操作可以互相转换。 以后你可能会遇到程序提示：按 q 键退出，或者按 s 键保存，可以试试看这两个字母是什么数字编码。 hex ，oct 和 bin1234567&gt;&gt;&gt; a = 100&gt;&gt;&gt; bin(a)'0b1100100'&gt;&gt;&gt; oct(a)'0o144'&gt;&gt;&gt; hex(a)'0x64' 注意操作后返回的是字符串格式，不再是数字哦 123456&gt;&gt;&gt; int(eval('0b1100100'))100&gt;&gt;&gt; eval('0b100')4&gt;&gt;&gt; type(eval('0b100'))&lt;class 'int'&gt; 这玩意儿写累了，拆开更吧，水一篇。 — 欲知后事是如何，且听下回分解]]></content>
      <categories>
        <category>Python 教程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[6.Python的math模块]]></title>
    <url>%2Fpython%2F6.Python%E7%9A%84math%E6%A8%A1%E5%9D%97.html</url>
    <content type="text"><![CDATA[书接上文这年头，自己造轮子的还是少啊，当你觉得别人的轮子不好用的时候，试试自己造一个，就会反省道：”真香” 我就是饿死，从这里跳下去，也绝不会用 math 模块的 123&gt;&gt;&gt; import math&gt;&gt;&gt; dir(math)['__doc__', '__loader__', '__name__', '__package__', '__spec__', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil', 'copysign', 'cos', 'cosh', 'degrees', 'e', 'erf', 'erfc', 'exp', 'expm1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma', 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf', 'nan', 'pi', 'pow', 'radians', 'remainder', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'tau', 'trunc'] dir 查看 math 查看包中的内容,每遇到一个新的模块，都可以用来看看，不讲了，懒得讲 Python常用数学函数 函数 返回值 abs(x) 返回数字的绝对值，如abs(-10) 返回 10 ceil(x) 返回数字的上入整数，如math.ceil(4.1) 返回 5 cmp(x,y) 如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1。已被删除 exp(x) 返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045 fabs(x) 返回数字的绝对值，如math.fabs(-10) 返回10.0 floor(x) 返回数字的下舍整数，如math.floor(4.9)返回 4 log(x) 如math.log(math.e)返回1.0,math.log(100,10)返回2.0 max(x1,x2,…) 返回给定参数的最大值，参数可以为序列。 min(x1,x2,…) 返回给定参数的最小值，参数可以为序列。 modf(x) 返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。 pow(x,y,z) x**y 运算后的值。 round(x,[n]) 浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数。 sqrt(x) 返回数字x的平方根 下面给出部分函数的示例，如果是没有数学基础，第一次看见这些函数，或者想要更多详细的参考，可以参考官方文档 或者，使用帮助命名 help _ :救救我 1234567891011121314151617181920212223242526272829303132333435363738&gt;&gt;&gt; import math&gt;&gt;&gt; help(math)Help on built-in module math:NAME mathDESCRIPTION This module provides access to the mathematical functions defined by the C standard.FUNCTIONS acos(x, /) Return the arc cosine (measured in radians) of x. acosh(x, /) Return the inverse hyperbolic cosine of x. asin(x, /) Return the arc sine (measured in radians) of x. asinh(x, /) Return the inverse hyperbolic sine of x. atan(x, /) Return the arc tangent (measured in radians) of x. atan2(y, x, /) Return the arc tangent (measured in radians) of y/x. Unlike atan(y/x), the signs of both x and y are considered. atanh(x, /) Return the inverse hyperbolic tangent of x. ceil(x, /) Return the ceiling of x as an Integral.# 还有很多 12345678910import mathprint(abs(-10),'\t',math.ceil(1.1),'\t',math.exp(1),'\n', max(1,2),'\t',math.floor(4.5),'\t',math.log(2,4),'\n', pow(2,5,2),'\t',math.sin(math.pi),'\t',math.modf(2.3),'\n', round(4.3334,2),'\t',math.cmp(1,2),'\t',math.cmp(1,1),'\n', math.cmp(2,1),'\t',math.sqrt(4),'\t', )#因为已经移除，会报错AttributeError: module 'math' has no attribute 'cmp' 123456789101112import mathprint(abs(-10),'\t\t',math.ceil(1.1),'\t'*5,math.exp(1),'\n', max(1,2),'\t\t',math.floor(4.5),'\t'*5,math.log(2,4),'\n', pow(2,5,2),'\t\t',math.sin(math.pi),'\t\t',math.modf(2.3),'\n', round(4.3334,2),'\t\t',math.sqrt(4),'\t\t', )10 2 2.718281828459045 2 4 0.5 0 1.2246467991473532e-16 (0.2999999999999998, 2.0) 4.33 2.0 那我们想要比较两个值的时候怎么办呢？ 12345&gt;&gt;&gt; import operator&gt;&gt;&gt; operator.eq('a','b')False&gt;&gt;&gt; operator.eq('a','a')True 需要导入 operator 模块 并且提供了以下内置函数： 123456789101112operator.lt(a, b) operator.le(a, b) operator.eq(a, b) operator.ne(a, b) operator.ge(a, b) operator.gt(a, b) operator.__lt__(a, b) operator.__le__(a, b) operator.__eq__(a, b) operator.__ne__(a, b) operator.__ge__(a, b) operator.__gt__(a, b) math 模块暂时结束探讨，其实我自己使用感觉不是太多，通常用的还是自带的函数，尤其很多数据分析包都有自己的数学模块，不过看 math 包的源码倒是对编程思维的锻炼大有裨益。有时间一起看看咯。 — 欲知后事是如何，且听下回分解]]></content>
      <categories>
        <category>Python 教程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何调用 OpenCV 读取摄像头图片保存在本地]]></title>
    <url>%2Freading%2FOpenCV%E8%B0%83%E7%94%A8%E6%91%84%E5%83%8F%E5%A4%B4%E6%8B%8D%E7%85%A7.html</url>
    <content type="text"><![CDATA[如何调用 OpenCV 读取摄像头图片保存在本地1.导入OenCV 库1import cv212print(cv2.__version__) #版本的重要性不言而喻4.1.02.创建一个 VideoCapture 对象1cap = cv2.VideoCapture(0) #如果你有其他摄像头，注意换参数 3.递增，用来保存文件名1num = 0 4.主程序12345678910111213141516171819while(cap.isOpened()):#循环读取每一帧 ret_flag, Vshow = cap.read() #返回两个参数，第一个是bool是否正常打开，第二个是照片数组， #如果只设置一个则变成一个tumple包含bool和图片 cv2.imshow("Capture_Test",Vshow) #窗口显示，显示名为 Capture_Test k = cv2.waitKey(1) &amp; 0xFF #每帧数据延时 1ms，延时不能为 0，否则读取的结果会是静态帧 if k == ord('s'): #若检测到按键 ‘s’，打印字符串 ''' 下面的存储路径改为你自己的文件路径，尽量不要有中文，num是上面的递增，保证新图片不会覆盖原图 ''' cv2.imwrite("images/"+ str(num) + ".jpg", Vshow) print(cap.get(3)); #得到长宽 print(cap.get(4)); print("success to save"+str(num)+".jpg") print("-------------------------") num += 1 elif k == ord('q'): #若检测到按键 ‘q’，退出 break 5.完整代码1234567891011121314151617181920import cv2cap = cv2.VideoCapture(0)num = 0while(cap.isOpened()):#循环读取每一帧 ret_flag, Vshow = cap.read() cv2.imshow("Capture_Test",Vshow) k = cv2.waitKey(1) &amp; 0xFF if k == ord('s'): ''' 下面的存储路径改为你自己的文件路径，尽量不要有中文，num是上面的递增，保证新图片不会覆盖原图 ''' cv2.imwrite("images/"+ str(num) + ".jpg", Vshow) print(cap.get(3)); print(cap.get(4)); print("success to save"+str(num)+".jpg") print("-------------------------") num += 1 elif k == ord('q'): break 6.效果展示]]></content>
      <categories>
        <category>一些笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[3.Python基础语法]]></title>
    <url>%2Fpython%2F3.Python%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html</url>
    <content type="text"><![CDATA[书接上文如果能够顺利地正确打印佛祖的的话，说明你是非常具有编程天赋的人。接下来，我们开始学习 Python 的基础语法，程序为了认识哪些单词是解释器自己的，哪些是程序员写的，规定了一些条条框框来限制大家不要瞎写。哪些是合法的命名规范呢？Python标识符在 Python 里，标识符由字母、数字、下划线组成。 在 Python 中，所有标识符可以包括英文、数字以及下划线(_)，但不能以数字开头。 Python 中的标识符是区分大小写的。 以下划线开头的标识符是有特殊意义的。以单下划线开头 _foo 的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用 from xxx import * 而导入。 以双下划线开头的 __foo 代表类的私有成员，以双下划线开头和结尾的 foo 代表 Python 里特殊方法专用的标识，如 init() 代表类的构造函数。 Python 可以同一行显示多条语句，方法是用分号 ; 分开，如： 123&gt;&gt;&gt; print('hello') ; print('world')helloworld 如果你学过其他语言，这个分号你一定很熟悉，很多语言都是用它作为语句的结束符，但是Python更加推荐用标准的代码缩进的方式来写程序。要注意空格和TAB键可是不能混用的，否则光凭肉眼可是很难发现问题所在。 行和缩进学习 Python 与其他语言最大的区别就是，Python 的代码块不使用大括号 {} 来控制类，函数以及其他逻辑判断。python 最具特色的就是用缩进来写模块。 缩进的空白数量是可变的，但是所有代码块语句必须包含相同的缩进空白数量，这个必须严格执行。如下所示： 1234if True: print("True")else: print("False") # 缩进不正确，同样等级的 print 你凭什么比上面的要高，是吧 12345$ python test.py File "test.py", line 10 print("False") ^IndentationError: unindent does not match any outer indentation level 错误提示显而易见呢，不但指出了行数，还指出了错误类型，不要忽略这些错误信息，不会的单词就去查，为了以后写BUG 改 BUG 快一点，不能偷懒 当然，光是正确书写标识符还不够，还要记得，程序都会带一群保留字符，这些都是程序的主料，总有一天你会挨个尝个遍，我们已经学了一个 print了，后续的学习之中，会逐步攻破的，不要看他有这么多 Python保留字符下面的列表显示了在Python中的保留字。这些保留字不能用作常数或变数，或任何其他标识符名称。 所有 Python 的关键字只包含小写字母。 and exec not assert finally or break for pass class from print continue global raise def if return del import try elif in while else is with except lambda yield 那么，一定要记住这些关键字吗？答案是：不用的，你只要使用比较明显表达含义的单词来写程序，一般是很难遇到使用关键字命名的情况，何况我们用自动补全的编辑器，要么高亮要么会有提示，这不是个问题，只是学到一定程度可以来看看，有哪些关键字你没有用到，高级程序员的话，基本上花里胡哨地用这些。加油吧。 多行语句Python语句中一般以新行作为语句的结束符。 但是我们可以使用斜杠（ \）将一行的语句分为多行显示，如下所示： 123total = item_one + \ item_two + \ item_three 后续的学习中，但凡是带括号的，[],{},(),直接换行也是可以的 Python引号Python 可以使用引号( ‘ )、双引号( “ )、三引号( ‘’’ 或 “”” ) 来表示字符串，引号的开始与结束必须的相同类型的。 其中三引号可以由多行组成，编写多行文本的快捷语法，常用于文档字符串，在文件的特定地点，被当做注释。 如果你的输出语句中带有多种引号，就挨个找成对的吧，对对碰一样，如果有单身的，那就有问题，或者他们就近组队了，后面乱了套，也会出问题 Python注释python中单行注释采用 # 开头。 12345678910111213# 第一个注释print("Hello, Python!") # 第二个注释'''第三个多行注释'''"""第四个多行注释""" 多个语句构成代码组123456if expression : suite elif expression : suite else : suite 命令行参数很多程序可以执行一些操作来查看一些基本信息，Python 可以使用 -h 参数查看各参数帮助信息： 123456789$ python -h usage: python [option] ... [-c cmd | -m mod | file | -] [arg] ... Options and arguments (and corresponding environment variables): -c cmd : program passed in as string (terminates option list) -d : debug output from parser (also PYTHONDEBUG=x) -E : ignore environment variables (such as PYTHONPATH) -h : print this help message and exit [ etc. ] — 欲知后事是如何，且听下回分解]]></content>
      <categories>
        <category>Python 教程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[4.Python 的变量类型]]></title>
    <url>%2Fpython%2F4.Python%20%E7%9A%84%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B.html</url>
    <content type="text"><![CDATA[书接上文了解了基本的编程规范，让我们来看看 Python 中的变量类型。变量变量也就是可以变化的值，可以把它比作是一个篮子，里面可以装苹果也可以装梨子。通常来讲，你要清楚你的目的是干什么，买苹果就拿符合苹果大小的篮子，如果你拿着只能装苹果的篮子去买西瓜，一定会跪在摊前认错。反之，拿着本来装西瓜的篮子去买一颗车厘子，实在是浪费了点。这也是为什么几乎所有的程序语言都要求你提前告知你要用什么篮子。 变量赋值Python 中的变量赋值不需要类型声明。 每个变量在内存中创建，都包括变量的标识，名称和数据这些信息。 每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。 等号（=）用来给变量赋值。 等号（=）运算符左边是一个变量名,等号（=）运算符右边是存储在变量中的值。例如： 123456#!/usr/bin/python# -*- coding: UTF-8 -*- counter = 100 # 赋值整型变量miles = 1000.0 # 浮点型name = "John" # 字符串 多个变量赋值1a = b = c = 1 # 这个操作在你需要创建几个空列表或者计数器时候非常好用 1a, b, c = 1, 2, "john" 上面这个例子其实是属于元组的解包操作，省略了圆括号，通常你如果看到类似这样的语句可以认为它是下面这样的 1a, b, c = (1, 2, "john") # 元组我们后面再讲 标准数据类型Python有五个标准的数据类型： Numbers（数字） String（字符串） List（列表） Tuple（元组） Dictionary（字典） 这5种基本的数据类型贯穿了你的整个Python编程生涯，所以务必要掌握它，基础操作还是要扎实才行 Python支持三种不同的数字类型： int（有符号整型） float（浮点型） complex（复数） 常用的 int 和 float ，也就是常说的整数和小数，现在的小朋友学习的时候教材已经将小数改为了浮点数 Python字符串字符串或串(String)是由数字、字母、下划线组成的一串字符。例如： 12345678910111213141516171819s = 'a_1_c''''如果你只想要字符串中的某一个，就要使用索引，索引就像班里的学号一样，只不过这里从0开始数所以：a_1_c正向索引a --- 0_ --- 11 --- 2_ --- 3c --- 4反向索引a --- -5_ --- -41 --- -3_ --- -2c --- -1''' 如果你想要某一部分，可以使用切片操作： 1s[0:2] # 'a_' 后面会详细介绍，这里只需要记住，取多少个字符，用切片尾数减去首位数就可以了，切片操作是取不到2的，这个区间在数学上算是左开右闭，[…) Python列表列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（即嵌套）。 列表用 [ ] 标识，是 python 最通用的复合数据类型。 列表中值的切割也可以用到变量 [头下标:尾下标] ，就可以截取相应的列表，从左到右索引默认 0 开始，从右到左索引默认 -1 开始，下标可以为空表示取到头或尾。 Python 元组元组是另一个数据类型，类似于 List（列表）。 元组用 () 标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于只读列表。 元组的精髓现在还无法体会，初学觉得它很废，它能做到的列表都能，直到天荒地老才知道元组最可贵 Python 字典字典(dictionary)是除列表以外python之中最灵活的内置数据结构类型。列表是有序的对象集合，字典是无序的对象集合。 两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。 字典用”{ }”标识。字典由索引(key)和它对应的值value组成。 1234567891011121314#!/usr/bin/python# -*- coding: UTF-8 -*- dict = &#123;&#125;dict['one'] = "This is one"dict[2] = "This is two" tinydict = &#123;'name': 'john','code':6734, 'dept': 'sales'&#125; print dict['one'] # 输出键为'one' 的值print dict[2] # 输出键为 2 的值print tinydict # 输出完整的字典print tinydict.keys() # 输出所有键print tinydict.values() # 输出所有值 字典提前说一下，因为它是无序的，当然不能够以之前的学号索引来取值，键你可以认为是你的名字，值就是你这个真真正正的人，别以为没有学号就找不到你了，凭你的名字也是可以找到你的，说到这里，你能感受到字典和列表的各种优缺点吗？比方说，一个考场，大家都按照顺序坐，阅卷的时候按照顺序打分真的方便，但是要是中间缺个两个，就麻烦了。字典好比老师手里攥着带你名字无形的线，随时可以顺着线找到你，海贼王有一个七武海就是这样 Python数据类型转换有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。 [int(x ,base]) 将x转换为一个整数 long(x [,base] ) 将x转换为一个长整数 float(x) 将x转换到一个浮点数 complex(real [,imag]) 创建一个复数 str(x) 将对象 x 转换为字符串 repr(x) 将对象 x 转换为表达式字符串 eval(str) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s) 将序列 s 转换为一个元组 list(s) 将序列 s 转换为一个列表 set(s) 转换为可变集合 dict(d) 创建一个字典。d 必须是一个序列 (key,value)元组。 frozenset(s) 转换为不可变集合 chr(x) 将一个整数转换为一个字符 unichr(x) 将一个整数转换为Unicode字符 ord(x) 将一个字符转换为它的整数值 hex(x) 将一个整数转换为一个十六进制字符串 oct(x) 将一个整数转换为一个八进制字符串 这个是真的挺方便的，不像其他语言，比如：str2int 这种骚操作，又难记又不好看，以后看到2要当成to ，O2O，P2P知道不，谐音命名法也是很骚的操作，以后可以用 guluguluwater 命名温泉 到这里为止都是简单介绍，从下一节开始可要动真格的了。相比于其他教程，接下来的内容重在深挖本质，这也是我为什么写这篇教程的原因，当初随便学学，基础不扎实，导致现在还要回炉。都是泪。 — 欲知后事是如何，且听下回分解]]></content>
      <categories>
        <category>Python 教程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2.安装 Anaconda]]></title>
    <url>%2Fpython%2F2.%E5%AE%89%E8%A3%85%20Anaconda.html</url>
    <content type="text"><![CDATA[书接上文上回书说到，Python的应用领域广泛，大家伙也有兴趣和我一起从头开始学习 Python ，那么怎么编写第一个 Python程序呢？不用说，我们需要一个可以编写 Python 代码的程序来帮助我们更快地入门。我推荐 Anaconda 这个集成环境来学习，就像你安装游戏一样双击就能安装，并且还会为我们下载很多常用的第三方库，这样我们就不用自己下载安装了。 PS:不要以为安装这个事情很简单，迟早会有自己安装第三方库因为版本问题捶胸顿足的时候 下载链接：https://www.anaconda.com/distribution/#download-section 选择合适自己的下载安装吧 在“开始”菜单中“Anaconda3”文件下找到“Jupyter Notebook”，点击进入: 选择 Python3，新建一个 Python 代码笔记本 修改文件名称，点击 untitled2 进行修改 点击进入代码编辑块，编辑：print(‘Hello World’)，Ctrl + Enter 进行运行 如果能够正常输出，那么说明安装成功了，并且你已经学会了 Python 的第一个程序，这将是你迈入编程世界最重要的一步 程序界有一个诅咒：如果你学习一门新的编程语言，不打印 Hello World ，那么你将学不会这门语言。 作业： 使用Jupyter Notebook打印： 世界，您好！ 您好，世界！ 打印佛祖： 123456789101112131415161718192021222324252627282930 1 * 2 * _ooOoo_ 3 * o8888888o 4 * 88" . "88 5 * (| -_- |) 6 * O\ = /O 7 * ____/`---'\____ 8 * .' \\| |// `. 9 * / \\||| : |||// \10 * / _||||| -:- |||||- \11 * | | \\\ - /// | |12 * | \_| ''\---/'' | |13 * \ .-\__ `-` ___/-. /14 * ___`. .' /--.--\ `. . __15 * ."" '&lt; `.___\_&lt;|&gt;_/___.' &gt;'"".16 * | | : `- \`.;`\ _ /`;.`/ - ` : | |17 * \ \ `-. \_ __\ /__ _/ .-` / /18 * ======`-.____`-.___\_____/___.-`____.-'======19 * `=---='20 * ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^21 * 佛祖保佑 永无BUG22 * 佛曰:23 * 写字楼里写字间，写字间里程序员；24 * 程序人员写程序，又拿程序换酒钱。25 * 酒醒只在网上坐，酒醉还来网下眠；26 * 酒醉酒醒日复日，网上网下年复年。27 * 但愿老死电脑间，不愿鞠躬老板前；28 * 奔驰宝马贵者趣，公交自行程序员。29 * 别人笑我忒疯癫，我笑自己命太贱；30 * 不见满街漂亮妹，哪个归得程序员？ 当我们虔诚地问候了这个世界之后，就可以开始我们的编程之旅了，佛祖保佑，永无BUG — 欲知后事是如何，且听下回分解]]></content>
      <categories>
        <category>Python 教程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[1.Python 介绍]]></title>
    <url>%2Fpython%2F1.Python%20%E4%BB%8B%E7%BB%8D.html</url>
    <content type="text"><![CDATA[Python 来了Python（英国发音：/ˈpaɪθən/ 美国发音：/ˈpaɪθɑːn/）是一种广泛使用的解释型、高级编程、通用型编程语言，由吉多·范罗苏姆创造，第一版发布于1991年。背景Python的创始人为吉多·范罗苏姆。1989年的圣诞节期间，吉多·范罗苏姆为了在阿姆斯特丹打发时间，决心开发一个新的脚本解释程序，作为ABC语言的一种继承。之所以选中Python作为程序的名字，是因为他是BBC电视剧——蒙提·派森的飞行马戏团的爱好者。 特性与设计哲学Python是完全面向对象的语言。函数、模块、数字、字符串都是对象。并且完全支持继承、重载、派生、多重继承，有益于增强源代码的复用性。 标准库为了代码的重用性，Python 在设计之初就包含了许多好用的库函数，避免重复造轮子。所以对于标准库的掌握是Python开发者必备技能。 我们可以看看标准库包含哪些功能呢？ Python标准库的主要功能有： 文本处理，包含文本格式化、正则表达式匹配、文本差异计算与合并、Unicode支持，二进制数据处理等功能 文件处理，包含文件操作、创建临时文件、文件压缩与归档、操作配置文件等功能 操作系统功能，包含线程与进程支持、IO复用、日期与时间处理、调用系统函数、日志（logging）等功能 网络通信，包含网络套接字，SSL加密通信、异步网络通信等功能 网络协议，支持HTTP，FTP，SMTP，POP，IMAP，NNTP，XMLRPC等多种网络协议，并提供了编写网络服务器的框架 W3C格式支持，包含HTML，SGML，XML的处理。 其它功能，包括国际化支持、数学运算、HASH、Tkinter等 想要详细了解 Python 的标准库？ 请访问官方标准库文档：https://docs.python.org/3/library/index.html 如果你是初学者，上面的库功能可能难以理解，是的，标准库就是安装 Python 自带的内置电池，也算是比较底层的东西。接下来，让我们不妨再看看 Python 的第三方库吧： 著名的第三方库：Web框架[编辑] Django 开源Web开发框架，它鼓励快速开发,并遵循MVC设计，开发周期短。 Flask 轻量级的Web框架。 Pyramid 轻量，同时有可以规模化的Web框架，Pylon projects 的一部分。 ActiveGrid 企业级的Web2.0解决方案。 Karrigell 简单的Web框架，自身包含了Web服务，py脚本引擎和纯python的数据库PyDBLite。 Tornado 一个轻量级的Web框架，内置非阻塞式服务器，而且速度相当快 webpy 一个小巧灵活的Web框架，虽然简单但是功能强大。 CherryPy 基于Python的Web应用程序开发框架。 Pylons 基于Python的一个极其高效和可靠的Web开发框架。 Zope 开源的Web应用服务器。 TurboGears 基于Python的MVC风格的Web应用程序框架。 Twisted 流行的网络编程库，大型Web框架。 Quixote Web开发框架。 aiohttp 轻量级的Web框架，采用的是Python3的asyncio异步特性。 科学计算[编辑] Matplotlib 用Python实现的类matlab的第三方库，用以绘制一些高质量的数学二维图形。 Pandas 用于数据分析、数据建模、数据可视化的第三方库。 SciPy 基于Python的matlab实现，旨在实现matlab的所有功能。 NumPy 基于Python的科学计算第三方库，提供了矩阵，线性代数，傅立叶变换等等的解决方案。 GUI[编辑] PyGtk 基于Python的GUI程序开发GTK+库。 PyQt 用于Python的QT开发库。 WxPython Python下的GUI编程框架，与MFC的架构相似。 其它[编辑] BeautifulSoup 基于Python的HTML/XML解析器，简单易用。 gevent python的一个高性能并发框架,使用了epoll事件监听、协程等机制将异步调用封装为同步调用。 PIL 基于Python的图像处理库，功能强大，对图形文件的格式支持广泛。当前已无维护，另一个第三方库Pillow实现了对PIL库的支持和维护。 PyGame 基于Python的多媒体开发和游戏软件开发模块。 Py2exe 将python脚本转换为windows上可以独立运行的可执行程序。 Requests 适合于人类使用的HTTP库，封装了许多繁琐的HTTP功能，极大地简化了HTTP请求所需要的代码量。 scikit-learn 机器学习第三方库，实现许多知名的机器学习算法。 TensorFlow Google开发维护的开源机器学习库。 Keras 基于TensorFlow，Theano与CNTK的高端神经网络API。 SQLAlchemy 关系型数据库的对象关系映射(ORM)工具 利用上面这些著名的第三方库，可以完成下面的方向。有你感兴趣的领域吗？ 1. WEB开发 2. 网络编程 3. 爬虫开发 4. 云计算开发 5. 人工智能 6. 自动化运维 7. 金融分析 8. 科学运算 9. 游戏开发 10. 桌面软件 如果你对下面的某一个或几个方向感兴趣，不妨试试 Python 吧，我将会和你一起从零开始学习这些，并且在每一个细分领域从实战出发进行学习，每一篇博客布置相应内容的习题帮助巩固，最后完结的时候，让我们共同攻克一个较为完整的项目。 文章参考： 参考文献 细则 维基百科 python python 官网 https://docs.python.org/3/library/index.html Python 作为一门编程语言，应用广泛。曾经有个伟人说过： 吾生也有涯，而知也无涯。以有涯随无涯，殆已！ 就是说这么多东西，等我学完，早挂掉了。莫非是劝我们弃疗？如何用有限的生命解锁 Python 技能呢？ —欲知后事如何，且听下回分解]]></content>
      <categories>
        <category>Python 教程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2.安装 Anaconda]]></title>
    <url>%2Fhomework%2FHello%20World.html</url>
    <content type="text"><![CDATA[12print('世界，您好！')print('您好，世界！') 世界，您好！ 您好，世界！12345678910111213141516171819202122232425262728 _ooOoo_ o8888888o 88" . "88 (| -_- |) O\ = /O ____/`---'\____ .' \\| |// `. / \\||| : |||// \ / _||||| -:- |||||- \ | | \\\ - /// | | | \_| ''\---/'' | | \ .-\__ `-` ___/-. / ___`. .' /--.--\ `. . __ ."" '&lt; `.___\_&lt;|&gt;_/___.' &gt;'"". | | : `- \`.;`\ _ /`;.`/ - ` : | | \ \ `-. \_ __\ /__ _/ .-` / /======`-.____`-.___\_____/___.-`____.-'====== `=---='^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 佛祖保佑 永无BUG 佛曰: 写字楼里写字间，写字间里程序员； 程序人员写程序，又拿程序换酒钱。 酒醒只在网上坐，酒醉还来网下眠； 酒醉酒醒日复日，网上网下年复年。 但愿老死电脑间，不愿鞠躬老板前； 奔驰宝马贵者趣，公交自行程序员。 别人笑我忒疯癫，我笑自己命太贱； 不见满街漂亮妹，哪个归得程序员？]]></content>
      <categories>
        <category>作业</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world.html</url>
    <content type="text"><![CDATA[第一篇博客就像程序员每学习一门新的编程语言的时候，首先输出：Hello World 一样，这篇博客也是我创建自己博客所迈出的第一步。为什么想起写博客在学习工作的过程中，从大家的博客中获益匪浅，也希望自己能够将学到的知识记录下来，分享出去。既可以给自己留下一点复习参考的笔记，又可以服务大家，能够有意或者无意帮助到别人，也算是赠人玫瑰，手留余香的快乐吧。 主要记录些什么作为自己的个人博客，我希望可以记录得随意一些。学习到的新知识，搜索记录的笔记，个人的人生感悟，生活中的一些琐碎，还有杂七杂八的兴趣吧 自己的一方天地生活中零零碎碎的事情，千丝万缕的关系，很难衷心地说出自己的想法，自己的思考。比起朋友圈，这里有更加独立的空间。虽然是公开博客，躲在这互联网的汪洋大海之中，谁也找不到，反而更能够沉下心来记录，感悟。]]></content>
  </entry>
</search>
